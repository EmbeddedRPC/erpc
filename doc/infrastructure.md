eRPC infrastructure
---------------------

This section describes the eRPC infrastructure, including infrastructure classes and eRPC generator outputs.

### Infrastructure classes
Infrastructure classes (in C++) are stored in the ``erpc/src/erpc`` directory. For simple use in C code, C-wrapper functions have been created (see ). The infrastructure classes are split into 4 folders: *transport*, *codec*, *client*, *server*.

#### *transport*
Stores different transport layers; transport layers connect eRPC applications with drivers for different transport mediums.
* Prototypes of functions for transport layers (which have to be declared for each transport medium that is used) are declared in the ``transport.h`` file.
* Each transport layer needs to at least send and the receive implementation.
* The ``message_buffer.h`` and ``message_buffer.cpp`` files are also located here. These files contain functions for working with message buffers (reading/writing data and others).

#### *codec*
Codecs are used for data serialization. Prototypes of functions for codecs are declared in ``codec.h`` file. The ``basic_codec.cpp`` file contains the first implementation of these functions.

#### *client*
The role of client is to create and to send eRPC requests to the server, and to process the received response (if requested).
* This is implemented in ``client_manager.h``/``.cpp`` files.
* The main functions are ``createRequest()``, ``performRequest()``, and ``releaseRequest()``.
* The transport layer and codec have to be set for the client manager.

#### *server*
The role of the server is to receive eRPC requests from the client side, to execute requested functions and to send the response back (if client requests a result).
* Prototypes of server functions are declared in server.h; common functions are defined in server.cpp. The ``simple_server.h``/``.cpp`` files contain the first implementation of server-declared functions.
* Transport layer and codec have to be set for the server.
* The ``server.h`` file also contains a prototype for a service class. For each interface declared in an IDL file, the definition for service is generated using the eRPC generator tool. These generated services must be added to the server after its initialization; without this step, the server cannot handle client requests.
* The simple server contains 2 functions for message processing: ``run`` and ``poll``. The ``poll`` function only supports the RPMsg transport layer.

Do not forget to add files with the prototypes described in each section into your application projects.

### Connections between user code, outputs from eRPC generator, and infrastructure classes
* Client and server applications have to initialize all infrastructures first (for example, server/client, transports, codecs, and others). Refer back to infrastructure classes.
* For simple use of those C++ objects, C-wrapper functions have been created for C-users. See [C-wrapper functions]().

### Client-side application
After an eRPC client initializes, the code is generated for the client side, and that code can be executed. This generated code for the client serializes data, and uses the client object to create, perform, and release the request. When these client services are no longer needed, call the quit function to tell the server that these client services are not needed anymore, and to de-initialize the client object (including the transport and codec that were used).

### Server-side application
After the eRPC server initializes, a service should be added to the server. Services are generated using the shim code for the server-side application. Each interface defined in an IDL file is generated as a server service (see interfaces and infrastructure classes). After that, the function for running the server can be executed. From this point in time, the server is waiting for requests from the client.

* When the server receives a message, the server identifies the right service from registered services, and calls the ``handleInvocation()`` function for this service. The ``handleInvocation()`` function is generated by the eRPC generator tool, and ``handleInvocation()`` provides the identification of which API function has to be executed.
* The called function performs data deserialization, and the corresponding function implementation is executed.
* If the API function returns a value(s), then the shim code serializes data for the client and sends it back (to the client).
* When server services are not requested anymore, the server should receive the quit request. The quit function implementation should contain code for stopping the server (because the implementation of the run function is in a loop). When the server is stopped, the server object should be de-initialized (including the transport and codec that were used).

# C-wrapper functions
C-wrapper functions are designed for use by the eRPC infrastructure, and do not require any knowledge of C++ programming to use. C-wrapper functions simplify using the eRPC in an application. C-wrapper functions are stored in 2 places.

### Client: ``erpc/src/erpc/client/``
* ``<client_setup.h>``: header file that contains declarations of C-wrapper functions for all supported transport layers.
* ``client_setup_<transport>.cpp``: contains definitions of C-wrapper functions for all supported transport layers, where ``<transport>`` specifies the type of transport layer.
Remember to add source and header files used in the ``client_setup_<transport>.cpp`` file to an application project. This includes the defined client type, transport layer, and codec type.

### Server: ``erpc/src/erpc/server/``
* ``server_setup.h``: header file that contains declarations of C-wrapper functions for all supported transport layers.
* ``server_setup_common.cpp``: contains common definitions of C-wrapper functions. These definitions are independent of the transport layer that is to be used.
* ``server_setup_<transport>.cpp``: contains definitions of C-wrapper functions for all supported transport layers, where ``<transport>`` specifies the type of transport layer.

Remember to add source and header files used in ``server_setup_<transport>.cpp`` file to an application project. This includes the defined server type, transport layer, and codec type.

## Client-side functions
For the client side (``client_setup`` files), there are 2 functions.

### *erpc_client_init()*
To initialize the client side of an eRPC application, the ``erpc_client_init()`` function must be called. The ClientManager object is created here and the transport layer, codec and message buffer factory are added into it. If the server is running, then the user can call functions generated from an IDL file.

### *erpc_client_deinit()*
When the client is not needed anymore, the ``erpc_client_deinit()`` function should be called. ``erpc_client_deinit()`` frees all memory allocated for the client side of the application.

The following image represents the basic code flow on the client side, and shows the order in which ``erpc`` C-wrapper functions and generated ``erpc`` functions are executed.

![Basic code flow on client side](images/client_side_flowchart.png)

## Server-side functions
For the server side (``server_setup`` files), there are 6 functions.

### *erpc_server_init()*
To initialize the server side of an eRPC application, the ``erpc_server_init()`` function must be called. The SimpleServer object is created here, and the transport layer, codec, and message buffer factory are added into it. After this initialization, one of the two functions to receive/send messages from/to the client should be called.

### *erpc_server_deinit()*
When the server is not needed anymore, the ``erpc_server_deinit()`` function should be called. ``erpc_server_deinit()`` frees all memory allocated for the server side of an application.

### *erpc_add_service_to_server()*
Adds a service to the server. When the server gets a request from the client, the server searches in its registered services to find the correct action for this request. The generated function (from an IDL file) is passed as a parameter for this function; see "Interfaces" section.

### *erpc_server_run()*
Calls the implementation of the ``run()`` function of the SimpleServer class. This is the 1st possible type of function for handling messages received from the client.

### *erpc_server_poll()*
Calls the implementation of the ``poll()`` function of the SimpleServer class. This is the 2nd possible type of function for handling messages received from the client.
* When the server is still on, returns true.
* When the server is not still on, returns false.
  * If false is returned, then the ``erpc_server_deinit()`` function should be called to free allocated space. After that, the server application should not call the ``erpc_server_deinit()`` function again.

### *erpc_stop_server()*
Informs the server that the client side will not use the server anymore.

The next two figures represent the basic code flow on the server side, and shows the order in which ``erpc`` C-wrapper functions and generated ``erpc`` functions are executed. As depicted, when the client calls the quit function, the ``erpc_server_stop()`` function should be called from inside the quit function implementation.

The first figure shows an eRPC application that is using the ``erpc_server_run()`` function. The implementation of this function is called in a loop until the ``erpc_server_stop()`` function is called.

![eRPC using *erpc_server_run()* function](images/eRPCwith_erpc_server_run_function.png)

The second figure shows an eRPC application that is using the ``erpc_server_poll()`` function. The implementation of this function is called repeatedly. It is up to the server application (user code), when (and how often) the server calls this function. This function should not be called after the quit function eRPC request has been received, i.e., when the ``erpc_server_poll()`` function returns false.

![eRPC using *erpc_server_poll()* function](images/eRPCusing_erpc_server_poll_function.png)
