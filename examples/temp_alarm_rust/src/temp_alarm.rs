/*!
 * Copyright (c) 2016, Freescale Semiconductor, Inc.
 * Copyright 2016-2017 NXP
 * All rights reserved.
 *
 *
 * SPDX-License-Identifier: BSD-3-Clause
 */

//
// Generated by erpcgen 1.14.0 on Thu Aug  7 14:41:40 2025.
//
// AUTOGENERATED - DO NOT EDIT
//

#![allow(unused_imports)]
#![allow(unused_variables)]
#![allow(dead_code)]
#![allow(non_camel_case_types)]
#![allow(unused_parens)]

use async_trait::async_trait;
use erpc_rust::{
    auxiliary::{MessageInfo, MessageType},
    codec::{BasicCodec, BasicCodecFactory, Codec},
    error::SerializationError,
    server::{BaseService, MethodHandler, Service},
    transport::Transport,
    ClientManager, ErpcResult,
};
use serde::{Deserialize, Serialize};
use std::sync::Arc;

/// Service IDs (automatically assigned by eRPC generator based on interface order)
#[repr(u8)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ServiceId {
    Temp = 1,
    TempAsync = 2,
}

impl ServiceId {
    pub fn as_u8(self) -> u8 {
        self as u8
    }
}

// Method IDs for each service
/// Temp method IDs
#[repr(u8)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum TempMethod {
    AddSensor = 1,
    RemoveSensor = 2,
    SetInterval = 3,
    SetAlarm = 4,
    EnableAlarm = 5,
    DisableAlarm = 6,
    GetOneSensor = 7,
    GetAllSensorsB = 8,
    SaveSettings = 9,
    LoadSettings = 10,
    ReadOneSensor = 11,
    ReadSensors = 12,
}

impl TempMethod {
    pub fn as_u8(self) -> u8 {
        self as u8
    }
}

/// TempAsync method IDs
#[repr(u8)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum TempAsyncMethod {
    AlarmFired = 1,
    ReadResults = 2,
}

impl TempAsyncMethod {
    pub fn as_u8(self) -> u8 {
        self as u8
    }
}

pub type SensorAddress = u8;

pub type SensorInfoList = Vec<SensorInfo>;

pub type SavedState = Vec<u8>;

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[repr(i32)]
pub enum AlarmType {
    /// <member kHighAlarm:0>
    kHighAlarm = 0, // kHighAlarm in eRPC
    /// <member kLowAlarm:1>
    kLowAlarm = 1, // kLowAlarm in eRPC
    /// <member kBothAlarms:2>
    kBothAlarms = 2, // kBothAlarms in eRPC
}

impl Default for AlarmType {
    fn default() -> Self {
        AlarmType::kHighAlarm
    }
}

impl AlarmType {
    pub fn write(&self, codec: &mut dyn Codec) -> ErpcResult<()> {
        codec.write_int32(*self as i32)?;
        Ok(())
    }

    pub fn read(codec: &mut dyn Codec) -> ErpcResult<Self> {
        let value = codec.read_int32()?;
        match value {
            0 => Ok(Self::kHighAlarm),
            1 => Ok(Self::kLowAlarm),
            2 => Ok(Self::kBothAlarms),
            _ => Err(SerializationError::InvalidEnumValue {
                value: value as i32,
                type_name: "AlarmType".to_string(),
            }
            .into()),
        }
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct AlarmInfo {
    /// <member temp:float>
    pub temp: f32, // float temp
    /// <member enabled:bool>
    pub enabled: bool, // bool enabled
}

impl Default for AlarmInfo {
    fn default() -> Self {
        Self {
            temp: 0.0,
            enabled: false,
        }
    }
}

impl AlarmInfo {
    pub fn write(&self, codec: &mut dyn Codec) -> ErpcResult<()> {
        codec.write_float(self.temp)?;
        codec.write_bool(self.enabled)?;
        Ok(())
    }

    pub fn read(codec: &mut dyn Codec) -> ErpcResult<Self> {
        Ok(Self {
            temp: codec.read_float()?,
            enabled: codec.read_bool()?,
        })
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct SensorInfo {
    /// <member address:SensorAddress>
    pub address: u8, // SensorAddress address
    /// <member readInterval:float>
    pub read_interval: f32, // float readInterval
    /// <member highAlarm:AlarmInfo>
    pub high_alarm: AlarmInfo, // AlarmInfo highAlarm
    /// <member lowAlarm:AlarmInfo>
    pub low_alarm: AlarmInfo, // AlarmInfo lowAlarm
}

impl Default for SensorInfo {
    fn default() -> Self {
        Self {
            address: 0,
            read_interval: 0.0,
            high_alarm: AlarmInfo::default(),
            low_alarm: AlarmInfo::default(),
        }
    }
}

impl SensorInfo {
    pub fn write(&self, codec: &mut dyn Codec) -> ErpcResult<()> {
        codec.write_uint8(self.address)?;
        codec.write_float(self.read_interval)?;
        self.high_alarm.write(codec)?;
        self.low_alarm.write(codec)?;
        Ok(())
    }

    pub fn read(codec: &mut dyn Codec) -> ErpcResult<Self> {
        Ok(Self {
            address: codec.read_uint8()?,
            read_interval: codec.read_float()?,
            high_alarm: AlarmInfo::read(codec)?,
            low_alarm: AlarmInfo::read(codec)?,
        })
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct SensorReadResult {
    /// <member address:SensorAddress>
    pub address: u8, // SensorAddress address
    /// <member temp:float>
    pub temp: f32, // float temp
}

impl Default for SensorReadResult {
    fn default() -> Self {
        Self {
            address: 0,
            temp: 0.0,
        }
    }
}

impl SensorReadResult {
    pub fn write(&self, codec: &mut dyn Codec) -> ErpcResult<()> {
        codec.write_uint8(self.address)?;
        codec.write_float(self.temp)?;
        Ok(())
    }

    pub fn read(codec: &mut dyn Codec) -> ErpcResult<Self> {
        Ok(Self {
            address: codec.read_uint8()?,
            temp: codec.read_float()?,
        })
    }
}

/// =======================================================================
/// Temp
/// =======================================================================

pub mod temp_server {
    use super::*;
    use std::sync::Arc;

    /// Generated trait containing eRPC methods that should be implemented for use with TempServer.
    #[async_trait]
    pub trait Temp: Send + Sync + 'static {
        /// <function(1) add_sensor-><member (return):bool> [<struct (fn) [0:<member address:SensorAddress>]>]>
        async fn add_sensor(
            &self,
            address: u8,
        ) -> Result<bool, Box<dyn std::error::Error + Send + Sync>>;
        /// <function(2) remove_sensor-><member (return):bool> [<struct (fn) [0:<member address:SensorAddress>]>]>
        async fn remove_sensor(
            &self,
            address: u8,
        ) -> Result<bool, Box<dyn std::error::Error + Send + Sync>>;
        /// <function(3) set_interval-><member (return):bool> [<struct (fn) [0:<member address:SensorAddress>, 1:<member interval:float>]>]>
        async fn set_interval(
            &self,
            address: u8,
            interval: f32,
        ) -> Result<bool, Box<dyn std::error::Error + Send + Sync>>;
        /// <function(4) set_alarm-><member (return):bool> [<struct (fn) [0:<member address:SensorAddress>, 1:<member alarmType:AlarmType>, 2:<member alarmTemp:float>]>]>
        async fn set_alarm(
            &self,
            address: u8,
            alarm_type: AlarmType,
            alarm_temp: f32,
        ) -> Result<bool, Box<dyn std::error::Error + Send + Sync>>;
        /// <function(5) enable_alarm-><member (return):bool> [<struct (fn) [0:<member address:SensorAddress>, 1:<member alarmType:AlarmType>]>]>
        async fn enable_alarm(
            &self,
            address: u8,
            alarm_type: AlarmType,
        ) -> Result<bool, Box<dyn std::error::Error + Send + Sync>>;
        /// <function(6) disable_alarm-><member (return):bool> [<struct (fn) [0:<member address:SensorAddress>, 1:<member alarmType:AlarmType>]>]>
        async fn disable_alarm(
            &self,
            address: u8,
            alarm_type: AlarmType,
        ) -> Result<bool, Box<dyn std::error::Error + Send + Sync>>;
        /// <function(7) get_one_sensor-><member (return):SensorInfo> [<struct (fn) [0:<member address:SensorAddress>]>]>
        async fn get_one_sensor(
            &self,
            address: u8,
        ) -> Result<SensorInfo, Box<dyn std::error::Error + Send + Sync>>;
        /// <function(8) get_all_sensors_b-><member (return):SensorInfoList> [<struct (fn) []>]>
        async fn get_all_sensors_b(
            &self,
        ) -> Result<Vec<SensorInfo>, Box<dyn std::error::Error + Send + Sync>>;
        /// <function(9) save_settings-><member (return):SavedState> [<struct (fn) []>]>
        async fn save_settings(&self) -> Result<Vec<u8>, Box<dyn std::error::Error + Send + Sync>>;
        /// <function(10) load_settings-><member (return):bool> [<struct (fn) [0:<member savedState:SavedState>]>]>
        async fn load_settings(
            &self,
            saved_state: Vec<u8>,
        ) -> Result<bool, Box<dyn std::error::Error + Send + Sync>>;
        /// <function(11) read_one_sensor-><member (return):float> [<struct (fn) [0:<member address:SensorAddress>]>]>
        async fn read_one_sensor(
            &self,
            address: u8,
        ) -> Result<f32, Box<dyn std::error::Error + Send + Sync>>;
        /// <function(12) read_sensors-><member (return):bool> [<struct (fn) [0:<member addresses:(list)>, 1:<member count:uint32>]>]>
        async fn read_sensors(
            &self,
            addresses: Vec<u8>,
        ) -> Result<bool, Box<dyn std::error::Error + Send + Sync>>;
    }

    /// Server wrapper for Temp service
    pub struct TempServer<T>
    where
        T: Temp,
    {
        inner: Arc<T>,
        base_service: BaseService,
    }

    impl<T> TempServer<T>
    where
        T: Temp,
    {
        /// Create a new TempServer with service implementation
        pub fn new(inner: T) -> Self {
            let inner_arc = Arc::new(inner);
            let base_service = Self::create_base_service(&inner_arc);
            Self {
                inner: inner_arc,
                base_service,
            }
        }

        /// Get a reference to the inner service implementation
        pub fn get_ref(&self) -> &T {
            &self.inner
        }

        /// Get the inner service implementation
        pub fn into_inner(self) -> Arc<T> {
            self.inner
        }

        fn create_base_service(service: &Arc<T>) -> BaseService {
            let mut base_service = BaseService::new(ServiceId::Temp.as_u8());

            // Register all method handlers
            Self::register_add_sensor(&mut base_service, Arc::clone(service));
            Self::register_remove_sensor(&mut base_service, Arc::clone(service));
            Self::register_set_interval(&mut base_service, Arc::clone(service));
            Self::register_set_alarm(&mut base_service, Arc::clone(service));
            Self::register_enable_alarm(&mut base_service, Arc::clone(service));
            Self::register_disable_alarm(&mut base_service, Arc::clone(service));
            Self::register_get_one_sensor(&mut base_service, Arc::clone(service));
            Self::register_get_all_sensors_b(&mut base_service, Arc::clone(service));
            Self::register_save_settings(&mut base_service, Arc::clone(service));
            Self::register_load_settings(&mut base_service, Arc::clone(service));
            Self::register_read_one_sensor(&mut base_service, Arc::clone(service));
            Self::register_read_sensors(&mut base_service, Arc::clone(service));

            base_service
        }

        fn register_add_sensor(base_service: &mut BaseService, service: Arc<T>) {
            struct AddSensorHandler<T: Temp> {
                service: Arc<T>,
            }

            #[async_trait]
            impl<T: Temp> MethodHandler for AddSensorHandler<T> {
                async fn handle(&self, sequence: u32, codec: &mut dyn Codec) -> ErpcResult<()> {
                    // Deserialize address parameter
                    let address = codec.read_uint8()?;

                    let result = self.service.add_sensor(address).await;
                    match result {
                        Ok(response) => {
                            let reply_info = MessageInfo::new(
                                MessageType::Reply,
                                ServiceId::Temp.as_u8(),
                                TempMethod::AddSensor.as_u8(),
                                sequence,
                            );
                            codec.start_write_message(&reply_info)?;
                            // Serialize response
                            codec.write_bool(response)?; // Return value
                            Ok(())
                        }
                        Err(_e) => {
                            let reply_info = MessageInfo::new(
                                MessageType::Reply,
                                ServiceId::Temp.as_u8(),
                                TempMethod::AddSensor.as_u8(),
                                sequence,
                            );
                            codec.start_write_message(&reply_info)?;
                            // Send error response with default out parameters
                            codec.write_bool(bool::default())?; // Error return value
                            Ok(())
                        }
                    }
                }
            }

            base_service.add_method(TempMethod::AddSensor.as_u8(), AddSensorHandler { service });
        }

        fn register_remove_sensor(base_service: &mut BaseService, service: Arc<T>) {
            struct RemoveSensorHandler<T: Temp> {
                service: Arc<T>,
            }

            #[async_trait]
            impl<T: Temp> MethodHandler for RemoveSensorHandler<T> {
                async fn handle(&self, sequence: u32, codec: &mut dyn Codec) -> ErpcResult<()> {
                    // Deserialize address parameter
                    let address = codec.read_uint8()?;

                    let result = self.service.remove_sensor(address).await;
                    match result {
                        Ok(response) => {
                            let reply_info = MessageInfo::new(
                                MessageType::Reply,
                                ServiceId::Temp.as_u8(),
                                TempMethod::RemoveSensor.as_u8(),
                                sequence,
                            );
                            codec.start_write_message(&reply_info)?;
                            // Serialize response
                            codec.write_bool(response)?; // Return value
                            Ok(())
                        }
                        Err(_e) => {
                            let reply_info = MessageInfo::new(
                                MessageType::Reply,
                                ServiceId::Temp.as_u8(),
                                TempMethod::RemoveSensor.as_u8(),
                                sequence,
                            );
                            codec.start_write_message(&reply_info)?;
                            // Send error response with default out parameters
                            codec.write_bool(bool::default())?; // Error return value
                            Ok(())
                        }
                    }
                }
            }

            base_service.add_method(
                TempMethod::RemoveSensor.as_u8(),
                RemoveSensorHandler { service },
            );
        }

        fn register_set_interval(base_service: &mut BaseService, service: Arc<T>) {
            struct SetIntervalHandler<T: Temp> {
                service: Arc<T>,
            }

            #[async_trait]
            impl<T: Temp> MethodHandler for SetIntervalHandler<T> {
                async fn handle(&self, sequence: u32, codec: &mut dyn Codec) -> ErpcResult<()> {
                    // Deserialize address parameter
                    let address = codec.read_uint8()?;

                    // Deserialize interval parameter
                    let interval = codec.read_float()?;

                    let result = self.service.set_interval(address, interval).await;
                    match result {
                        Ok(response) => {
                            let reply_info = MessageInfo::new(
                                MessageType::Reply,
                                ServiceId::Temp.as_u8(),
                                TempMethod::SetInterval.as_u8(),
                                sequence,
                            );
                            codec.start_write_message(&reply_info)?;
                            // Serialize response
                            codec.write_bool(response)?; // Return value
                            Ok(())
                        }
                        Err(_e) => {
                            let reply_info = MessageInfo::new(
                                MessageType::Reply,
                                ServiceId::Temp.as_u8(),
                                TempMethod::SetInterval.as_u8(),
                                sequence,
                            );
                            codec.start_write_message(&reply_info)?;
                            // Send error response with default out parameters
                            codec.write_bool(bool::default())?; // Error return value
                            Ok(())
                        }
                    }
                }
            }

            base_service.add_method(
                TempMethod::SetInterval.as_u8(),
                SetIntervalHandler { service },
            );
        }

        fn register_set_alarm(base_service: &mut BaseService, service: Arc<T>) {
            struct SetAlarmHandler<T: Temp> {
                service: Arc<T>,
            }

            #[async_trait]
            impl<T: Temp> MethodHandler for SetAlarmHandler<T> {
                async fn handle(&self, sequence: u32, codec: &mut dyn Codec) -> ErpcResult<()> {
                    // Deserialize address parameter
                    let address = codec.read_uint8()?;

                    // Deserialize alarm_type parameter
                    let alarm_type = AlarmType::read(codec)?;

                    // Deserialize alarm_temp parameter
                    let alarm_temp = codec.read_float()?;

                    let result = self
                        .service
                        .set_alarm(address, alarm_type, alarm_temp)
                        .await;
                    match result {
                        Ok(response) => {
                            let reply_info = MessageInfo::new(
                                MessageType::Reply,
                                ServiceId::Temp.as_u8(),
                                TempMethod::SetAlarm.as_u8(),
                                sequence,
                            );
                            codec.start_write_message(&reply_info)?;
                            // Serialize response
                            codec.write_bool(response)?; // Return value
                            Ok(())
                        }
                        Err(_e) => {
                            let reply_info = MessageInfo::new(
                                MessageType::Reply,
                                ServiceId::Temp.as_u8(),
                                TempMethod::SetAlarm.as_u8(),
                                sequence,
                            );
                            codec.start_write_message(&reply_info)?;
                            // Send error response with default out parameters
                            codec.write_bool(bool::default())?; // Error return value
                            Ok(())
                        }
                    }
                }
            }

            base_service.add_method(TempMethod::SetAlarm.as_u8(), SetAlarmHandler { service });
        }

        fn register_enable_alarm(base_service: &mut BaseService, service: Arc<T>) {
            struct EnableAlarmHandler<T: Temp> {
                service: Arc<T>,
            }

            #[async_trait]
            impl<T: Temp> MethodHandler for EnableAlarmHandler<T> {
                async fn handle(&self, sequence: u32, codec: &mut dyn Codec) -> ErpcResult<()> {
                    // Deserialize address parameter
                    let address = codec.read_uint8()?;

                    // Deserialize alarm_type parameter
                    let alarm_type = AlarmType::read(codec)?;

                    let result = self.service.enable_alarm(address, alarm_type).await;
                    match result {
                        Ok(response) => {
                            let reply_info = MessageInfo::new(
                                MessageType::Reply,
                                ServiceId::Temp.as_u8(),
                                TempMethod::EnableAlarm.as_u8(),
                                sequence,
                            );
                            codec.start_write_message(&reply_info)?;
                            // Serialize response
                            codec.write_bool(response)?; // Return value
                            Ok(())
                        }
                        Err(_e) => {
                            let reply_info = MessageInfo::new(
                                MessageType::Reply,
                                ServiceId::Temp.as_u8(),
                                TempMethod::EnableAlarm.as_u8(),
                                sequence,
                            );
                            codec.start_write_message(&reply_info)?;
                            // Send error response with default out parameters
                            codec.write_bool(bool::default())?; // Error return value
                            Ok(())
                        }
                    }
                }
            }

            base_service.add_method(
                TempMethod::EnableAlarm.as_u8(),
                EnableAlarmHandler { service },
            );
        }

        fn register_disable_alarm(base_service: &mut BaseService, service: Arc<T>) {
            struct DisableAlarmHandler<T: Temp> {
                service: Arc<T>,
            }

            #[async_trait]
            impl<T: Temp> MethodHandler for DisableAlarmHandler<T> {
                async fn handle(&self, sequence: u32, codec: &mut dyn Codec) -> ErpcResult<()> {
                    // Deserialize address parameter
                    let address = codec.read_uint8()?;

                    // Deserialize alarm_type parameter
                    let alarm_type = AlarmType::read(codec)?;

                    let result = self.service.disable_alarm(address, alarm_type).await;
                    match result {
                        Ok(response) => {
                            let reply_info = MessageInfo::new(
                                MessageType::Reply,
                                ServiceId::Temp.as_u8(),
                                TempMethod::DisableAlarm.as_u8(),
                                sequence,
                            );
                            codec.start_write_message(&reply_info)?;
                            // Serialize response
                            codec.write_bool(response)?; // Return value
                            Ok(())
                        }
                        Err(_e) => {
                            let reply_info = MessageInfo::new(
                                MessageType::Reply,
                                ServiceId::Temp.as_u8(),
                                TempMethod::DisableAlarm.as_u8(),
                                sequence,
                            );
                            codec.start_write_message(&reply_info)?;
                            // Send error response with default out parameters
                            codec.write_bool(bool::default())?; // Error return value
                            Ok(())
                        }
                    }
                }
            }

            base_service.add_method(
                TempMethod::DisableAlarm.as_u8(),
                DisableAlarmHandler { service },
            );
        }

        fn register_get_one_sensor(base_service: &mut BaseService, service: Arc<T>) {
            struct GetOneSensorHandler<T: Temp> {
                service: Arc<T>,
            }

            #[async_trait]
            impl<T: Temp> MethodHandler for GetOneSensorHandler<T> {
                async fn handle(&self, sequence: u32, codec: &mut dyn Codec) -> ErpcResult<()> {
                    // Deserialize address parameter
                    let address = codec.read_uint8()?;

                    let result = self.service.get_one_sensor(address).await;
                    match result {
                        Ok(response) => {
                            let reply_info = MessageInfo::new(
                                MessageType::Reply,
                                ServiceId::Temp.as_u8(),
                                TempMethod::GetOneSensor.as_u8(),
                                sequence,
                            );
                            codec.start_write_message(&reply_info)?;
                            // Serialize response
                            response.write(codec)?; // Return value
                            Ok(())
                        }
                        Err(_e) => {
                            let reply_info = MessageInfo::new(
                                MessageType::Reply,
                                ServiceId::Temp.as_u8(),
                                TempMethod::GetOneSensor.as_u8(),
                                sequence,
                            );
                            codec.start_write_message(&reply_info)?;
                            // Send error response with default out parameters
                            SensorInfo::default().write(codec)?; // Error return value
                            Ok(())
                        }
                    }
                }
            }

            base_service.add_method(
                TempMethod::GetOneSensor.as_u8(),
                GetOneSensorHandler { service },
            );
        }

        fn register_get_all_sensors_b(base_service: &mut BaseService, service: Arc<T>) {
            struct GetAllSensorsBHandler<T: Temp> {
                service: Arc<T>,
            }

            #[async_trait]
            impl<T: Temp> MethodHandler for GetAllSensorsBHandler<T> {
                async fn handle(&self, sequence: u32, codec: &mut dyn Codec) -> ErpcResult<()> {
                    let result = self.service.get_all_sensors_b().await;
                    match result {
                        Ok(response) => {
                            let reply_info = MessageInfo::new(
                                MessageType::Reply,
                                ServiceId::Temp.as_u8(),
                                TempMethod::GetAllSensorsB.as_u8(),
                                sequence,
                            );
                            codec.start_write_message(&reply_info)?;
                            // Serialize response
                            codec.start_write_list(response.len() as u32)?;
                            for item in &response {
                                item.write(codec)?;
                            } // Return value
                            Ok(())
                        }
                        Err(_e) => {
                            let reply_info = MessageInfo::new(
                                MessageType::Reply,
                                ServiceId::Temp.as_u8(),
                                TempMethod::GetAllSensorsB.as_u8(),
                                sequence,
                            );
                            codec.start_write_message(&reply_info)?;
                            // Send error response with default out parameters
                            codec.start_write_list(0)?; // Error return value
                            Ok(())
                        }
                    }
                }
            }

            base_service.add_method(
                TempMethod::GetAllSensorsB.as_u8(),
                GetAllSensorsBHandler { service },
            );
        }

        fn register_save_settings(base_service: &mut BaseService, service: Arc<T>) {
            struct SaveSettingsHandler<T: Temp> {
                service: Arc<T>,
            }

            #[async_trait]
            impl<T: Temp> MethodHandler for SaveSettingsHandler<T> {
                async fn handle(&self, sequence: u32, codec: &mut dyn Codec) -> ErpcResult<()> {
                    let result = self.service.save_settings().await;
                    match result {
                        Ok(response) => {
                            let reply_info = MessageInfo::new(
                                MessageType::Reply,
                                ServiceId::Temp.as_u8(),
                                TempMethod::SaveSettings.as_u8(),
                                sequence,
                            );
                            codec.start_write_message(&reply_info)?;
                            // Serialize response
                            codec.write_binary(&response)?; // Return value
                            Ok(())
                        }
                        Err(_e) => {
                            let reply_info = MessageInfo::new(
                                MessageType::Reply,
                                ServiceId::Temp.as_u8(),
                                TempMethod::SaveSettings.as_u8(),
                                sequence,
                            );
                            codec.start_write_message(&reply_info)?;
                            // Send error response with default out parameters
                            codec.write_binary(&Vec::<u8>::default())?; // Error return value
                            Ok(())
                        }
                    }
                }
            }

            base_service.add_method(
                TempMethod::SaveSettings.as_u8(),
                SaveSettingsHandler { service },
            );
        }

        fn register_load_settings(base_service: &mut BaseService, service: Arc<T>) {
            struct LoadSettingsHandler<T: Temp> {
                service: Arc<T>,
            }

            #[async_trait]
            impl<T: Temp> MethodHandler for LoadSettingsHandler<T> {
                async fn handle(&self, sequence: u32, codec: &mut dyn Codec) -> ErpcResult<()> {
                    // Deserialize saved_state parameter
                    let saved_state = codec.read_binary()?;

                    let result = self.service.load_settings(saved_state).await;
                    match result {
                        Ok(response) => {
                            let reply_info = MessageInfo::new(
                                MessageType::Reply,
                                ServiceId::Temp.as_u8(),
                                TempMethod::LoadSettings.as_u8(),
                                sequence,
                            );
                            codec.start_write_message(&reply_info)?;
                            // Serialize response
                            codec.write_bool(response)?; // Return value
                            Ok(())
                        }
                        Err(_e) => {
                            let reply_info = MessageInfo::new(
                                MessageType::Reply,
                                ServiceId::Temp.as_u8(),
                                TempMethod::LoadSettings.as_u8(),
                                sequence,
                            );
                            codec.start_write_message(&reply_info)?;
                            // Send error response with default out parameters
                            codec.write_bool(bool::default())?; // Error return value
                            Ok(())
                        }
                    }
                }
            }

            base_service.add_method(
                TempMethod::LoadSettings.as_u8(),
                LoadSettingsHandler { service },
            );
        }

        fn register_read_one_sensor(base_service: &mut BaseService, service: Arc<T>) {
            struct ReadOneSensorHandler<T: Temp> {
                service: Arc<T>,
            }

            #[async_trait]
            impl<T: Temp> MethodHandler for ReadOneSensorHandler<T> {
                async fn handle(&self, sequence: u32, codec: &mut dyn Codec) -> ErpcResult<()> {
                    // Deserialize address parameter
                    let address = codec.read_uint8()?;

                    let result = self.service.read_one_sensor(address).await;
                    match result {
                        Ok(response) => {
                            let reply_info = MessageInfo::new(
                                MessageType::Reply,
                                ServiceId::Temp.as_u8(),
                                TempMethod::ReadOneSensor.as_u8(),
                                sequence,
                            );
                            codec.start_write_message(&reply_info)?;
                            // Serialize response
                            codec.write_float(response)?; // Return value
                            Ok(())
                        }
                        Err(_e) => {
                            let reply_info = MessageInfo::new(
                                MessageType::Reply,
                                ServiceId::Temp.as_u8(),
                                TempMethod::ReadOneSensor.as_u8(),
                                sequence,
                            );
                            codec.start_write_message(&reply_info)?;
                            // Send error response with default out parameters
                            codec.write_float(f32::default())?; // Error return value
                            Ok(())
                        }
                    }
                }
            }

            base_service.add_method(
                TempMethod::ReadOneSensor.as_u8(),
                ReadOneSensorHandler { service },
            );
        }

        fn register_read_sensors(base_service: &mut BaseService, service: Arc<T>) {
            struct ReadSensorsHandler<T: Temp> {
                service: Arc<T>,
            }

            #[async_trait]
            impl<T: Temp> MethodHandler for ReadSensorsHandler<T> {
                async fn handle(&self, sequence: u32, codec: &mut dyn Codec) -> ErpcResult<()> {
                    // Deserialize addresses parameter
                    let addresses = (|| -> ErpcResult<Vec<_>> {
                        let list_len = codec.start_read_list()?;
                        let mut list = Vec::new();
                        for _ in 0..list_len {
                            list.push(codec.read_uint8()?);
                        }
                        Ok(list)
                    })()?;

                    let result = self.service.read_sensors(addresses).await;
                    match result {
                        Ok(response) => {
                            let reply_info = MessageInfo::new(
                                MessageType::Reply,
                                ServiceId::Temp.as_u8(),
                                TempMethod::ReadSensors.as_u8(),
                                sequence,
                            );
                            codec.start_write_message(&reply_info)?;
                            // Serialize response
                            codec.write_bool(response)?; // Return value
                            Ok(())
                        }
                        Err(_e) => {
                            let reply_info = MessageInfo::new(
                                MessageType::Reply,
                                ServiceId::Temp.as_u8(),
                                TempMethod::ReadSensors.as_u8(),
                                sequence,
                            );
                            codec.start_write_message(&reply_info)?;
                            // Send error response with default out parameters
                            codec.write_bool(bool::default())?; // Error return value
                            Ok(())
                        }
                    }
                }
            }

            base_service.add_method(
                TempMethod::ReadSensors.as_u8(),
                ReadSensorsHandler { service },
            );
        }
    }

    /// Implementation of Service trait for TempServer
    #[async_trait]
    impl<T> Service for TempServer<T>
    where
        T: Temp,
    {
        fn service_id(&self) -> u8 {
            self.base_service.service_id()
        }

        async fn handle_invocation(
            &self,
            method_id: u8,
            sequence: u32,
            codec: &mut dyn Codec,
        ) -> ErpcResult<()> {
            self.base_service
                .handle_invocation(method_id, sequence, codec)
                .await
        }

        fn supported_methods(&self) -> Vec<u8> {
            self.base_service.supported_methods()
        }
    }

    /// Client implementation for Temp
    pub struct TempClient<'a, T>
    where
        T: Transport,
    {
        client: &'a mut ClientManager<T, BasicCodecFactory>,
    }

    /// Temp client implementation
    /// Matches eRPC IDL interface exactly with proper serialization
    impl<'a, T> TempClient<'a, T>
    where
        T: Transport,
    {
        pub fn new(client_manager: &'a mut ClientManager<T, BasicCodecFactory>) -> Self {
            Self {
                client: client_manager,
            }
        }

        /// <function(1) add_sensor-><member (return):bool> [<struct (fn) [0:<member address:SensorAddress>]>]>
        pub async fn add_sensor(
            &mut self,
            address: u8,
        ) -> Result<bool, Box<dyn std::error::Error + Send + Sync>> {
            // Serialize parameters to request_data
            let mut request_codec = BasicCodec::new();

            // Write address
            request_codec.write_uint8(address)?;

            let request_data = request_codec.as_bytes().to_vec();

            let response_data = self
                .client
                .perform_request(
                    ServiceId::Temp.as_u8(),
                    TempMethod::AddSensor.as_u8(),
                    false,
                    request_data,
                )
                .await?;
            // Deserialize response_data
            if response_data.is_empty() {
                return Err("Empty response data received".into());
            }

            let mut response_codec = BasicCodec::from_data(response_data);

            // Read return value
            let result = (&mut response_codec).read_bool()?;
            Ok(result)
        }

        /// <function(2) remove_sensor-><member (return):bool> [<struct (fn) [0:<member address:SensorAddress>]>]>
        pub async fn remove_sensor(
            &mut self,
            address: u8,
        ) -> Result<bool, Box<dyn std::error::Error + Send + Sync>> {
            // Serialize parameters to request_data
            let mut request_codec = BasicCodec::new();

            // Write address
            request_codec.write_uint8(address)?;

            let request_data = request_codec.as_bytes().to_vec();

            let response_data = self
                .client
                .perform_request(
                    ServiceId::Temp.as_u8(),
                    TempMethod::RemoveSensor.as_u8(),
                    false,
                    request_data,
                )
                .await?;
            // Deserialize response_data
            if response_data.is_empty() {
                return Err("Empty response data received".into());
            }

            let mut response_codec = BasicCodec::from_data(response_data);

            // Read return value
            let result = (&mut response_codec).read_bool()?;
            Ok(result)
        }

        /// <function(3) set_interval-><member (return):bool> [<struct (fn) [0:<member address:SensorAddress>, 1:<member interval:float>]>]>
        pub async fn set_interval(
            &mut self,
            address: u8,
            interval: f32,
        ) -> Result<bool, Box<dyn std::error::Error + Send + Sync>> {
            // Serialize parameters to request_data
            let mut request_codec = BasicCodec::new();

            // Write address
            request_codec.write_uint8(address)?;
            // Write interval
            request_codec.write_float(interval)?;

            let request_data = request_codec.as_bytes().to_vec();

            let response_data = self
                .client
                .perform_request(
                    ServiceId::Temp.as_u8(),
                    TempMethod::SetInterval.as_u8(),
                    false,
                    request_data,
                )
                .await?;
            // Deserialize response_data
            if response_data.is_empty() {
                return Err("Empty response data received".into());
            }

            let mut response_codec = BasicCodec::from_data(response_data);

            // Read return value
            let result = (&mut response_codec).read_bool()?;
            Ok(result)
        }

        /// <function(4) set_alarm-><member (return):bool> [<struct (fn) [0:<member address:SensorAddress>, 1:<member alarmType:AlarmType>, 2:<member alarmTemp:float>]>]>
        pub async fn set_alarm(
            &mut self,
            address: u8,
            alarm_type: AlarmType,
            alarm_temp: f32,
        ) -> Result<bool, Box<dyn std::error::Error + Send + Sync>> {
            // Serialize parameters to request_data
            let mut request_codec = BasicCodec::new();

            // Write address
            request_codec.write_uint8(address)?;
            // Write alarm_type
            alarm_type.write(&mut request_codec)?;
            // Write alarm_temp
            request_codec.write_float(alarm_temp)?;

            let request_data = request_codec.as_bytes().to_vec();

            let response_data = self
                .client
                .perform_request(
                    ServiceId::Temp.as_u8(),
                    TempMethod::SetAlarm.as_u8(),
                    false,
                    request_data,
                )
                .await?;
            // Deserialize response_data
            if response_data.is_empty() {
                return Err("Empty response data received".into());
            }

            let mut response_codec = BasicCodec::from_data(response_data);

            // Read return value
            let result = (&mut response_codec).read_bool()?;
            Ok(result)
        }

        /// <function(5) enable_alarm-><member (return):bool> [<struct (fn) [0:<member address:SensorAddress>, 1:<member alarmType:AlarmType>]>]>
        pub async fn enable_alarm(
            &mut self,
            address: u8,
            alarm_type: AlarmType,
        ) -> Result<bool, Box<dyn std::error::Error + Send + Sync>> {
            // Serialize parameters to request_data
            let mut request_codec = BasicCodec::new();

            // Write address
            request_codec.write_uint8(address)?;
            // Write alarm_type
            alarm_type.write(&mut request_codec)?;

            let request_data = request_codec.as_bytes().to_vec();

            let response_data = self
                .client
                .perform_request(
                    ServiceId::Temp.as_u8(),
                    TempMethod::EnableAlarm.as_u8(),
                    false,
                    request_data,
                )
                .await?;
            // Deserialize response_data
            if response_data.is_empty() {
                return Err("Empty response data received".into());
            }

            let mut response_codec = BasicCodec::from_data(response_data);

            // Read return value
            let result = (&mut response_codec).read_bool()?;
            Ok(result)
        }

        /// <function(6) disable_alarm-><member (return):bool> [<struct (fn) [0:<member address:SensorAddress>, 1:<member alarmType:AlarmType>]>]>
        pub async fn disable_alarm(
            &mut self,
            address: u8,
            alarm_type: AlarmType,
        ) -> Result<bool, Box<dyn std::error::Error + Send + Sync>> {
            // Serialize parameters to request_data
            let mut request_codec = BasicCodec::new();

            // Write address
            request_codec.write_uint8(address)?;
            // Write alarm_type
            alarm_type.write(&mut request_codec)?;

            let request_data = request_codec.as_bytes().to_vec();

            let response_data = self
                .client
                .perform_request(
                    ServiceId::Temp.as_u8(),
                    TempMethod::DisableAlarm.as_u8(),
                    false,
                    request_data,
                )
                .await?;
            // Deserialize response_data
            if response_data.is_empty() {
                return Err("Empty response data received".into());
            }

            let mut response_codec = BasicCodec::from_data(response_data);

            // Read return value
            let result = (&mut response_codec).read_bool()?;
            Ok(result)
        }

        /// <function(7) get_one_sensor-><member (return):SensorInfo> [<struct (fn) [0:<member address:SensorAddress>]>]>
        pub async fn get_one_sensor(
            &mut self,
            address: u8,
        ) -> Result<SensorInfo, Box<dyn std::error::Error + Send + Sync>> {
            // Serialize parameters to request_data
            let mut request_codec = BasicCodec::new();

            // Write address
            request_codec.write_uint8(address)?;

            let request_data = request_codec.as_bytes().to_vec();

            let response_data = self
                .client
                .perform_request(
                    ServiceId::Temp.as_u8(),
                    TempMethod::GetOneSensor.as_u8(),
                    false,
                    request_data,
                )
                .await?;
            // Deserialize response_data
            if response_data.is_empty() {
                return Err("Empty response data received".into());
            }

            let mut response_codec = BasicCodec::from_data(response_data);

            // Read return value
            let result = SensorInfo::read((&mut response_codec))?;
            Ok(result)
        }

        /// <function(8) get_all_sensors_b-><member (return):SensorInfoList> [<struct (fn) []>]>
        pub async fn get_all_sensors_b(
            &mut self,
        ) -> Result<Vec<SensorInfo>, Box<dyn std::error::Error + Send + Sync>> {
            // Serialize parameters to request_data
            let request_codec = BasicCodec::new();

            // No parameters to serialize

            let request_data = request_codec.as_bytes().to_vec();

            let response_data = self
                .client
                .perform_request(
                    ServiceId::Temp.as_u8(),
                    TempMethod::GetAllSensorsB.as_u8(),
                    false,
                    request_data,
                )
                .await?;
            // Deserialize response_data
            if response_data.is_empty() {
                return Err("Empty response data received".into());
            }

            let mut response_codec = BasicCodec::from_data(response_data);

            // Read return value
            let result = (|| -> ErpcResult<Vec<_>> {
                let list_len = (&mut response_codec).start_read_list()?;
                let mut list = Vec::new();
                for _ in 0..list_len {
                    list.push(SensorInfo::read((&mut response_codec))?);
                }
                Ok(list)
            })()?;
            Ok(result)
        }

        /// <function(9) save_settings-><member (return):SavedState> [<struct (fn) []>]>
        pub async fn save_settings(
            &mut self,
        ) -> Result<Vec<u8>, Box<dyn std::error::Error + Send + Sync>> {
            // Serialize parameters to request_data
            let request_codec = BasicCodec::new();

            // No parameters to serialize

            let request_data = request_codec.as_bytes().to_vec();

            let response_data = self
                .client
                .perform_request(
                    ServiceId::Temp.as_u8(),
                    TempMethod::SaveSettings.as_u8(),
                    false,
                    request_data,
                )
                .await?;
            // Deserialize response_data
            if response_data.is_empty() {
                return Err("Empty response data received".into());
            }

            let mut response_codec = BasicCodec::from_data(response_data);

            // Read return value
            let result = (&mut response_codec).read_binary()?;
            Ok(result)
        }

        /// <function(10) load_settings-><member (return):bool> [<struct (fn) [0:<member savedState:SavedState>]>]>
        pub async fn load_settings(
            &mut self,
            saved_state: Vec<u8>,
        ) -> Result<bool, Box<dyn std::error::Error + Send + Sync>> {
            // Serialize parameters to request_data
            let mut request_codec = BasicCodec::new();

            // Write saved_state
            request_codec.write_binary(&saved_state)?;

            let request_data = request_codec.as_bytes().to_vec();

            let response_data = self
                .client
                .perform_request(
                    ServiceId::Temp.as_u8(),
                    TempMethod::LoadSettings.as_u8(),
                    false,
                    request_data,
                )
                .await?;
            // Deserialize response_data
            if response_data.is_empty() {
                return Err("Empty response data received".into());
            }

            let mut response_codec = BasicCodec::from_data(response_data);

            // Read return value
            let result = (&mut response_codec).read_bool()?;
            Ok(result)
        }

        /// <function(11) read_one_sensor-><member (return):float> [<struct (fn) [0:<member address:SensorAddress>]>]>
        pub async fn read_one_sensor(
            &mut self,
            address: u8,
        ) -> Result<f32, Box<dyn std::error::Error + Send + Sync>> {
            // Serialize parameters to request_data
            let mut request_codec = BasicCodec::new();

            // Write address
            request_codec.write_uint8(address)?;

            let request_data = request_codec.as_bytes().to_vec();

            let response_data = self
                .client
                .perform_request(
                    ServiceId::Temp.as_u8(),
                    TempMethod::ReadOneSensor.as_u8(),
                    false,
                    request_data,
                )
                .await?;
            // Deserialize response_data
            if response_data.is_empty() {
                return Err("Empty response data received".into());
            }

            let mut response_codec = BasicCodec::from_data(response_data);

            // Read return value
            let result = (&mut response_codec).read_float()?;
            Ok(result)
        }

        /// <function(12) read_sensors-><member (return):bool> [<struct (fn) [0:<member addresses:(list)>, 1:<member count:uint32>]>]>
        pub async fn read_sensors(
            &mut self,
            addresses: Vec<u8>,
        ) -> Result<bool, Box<dyn std::error::Error + Send + Sync>> {
            // Serialize parameters to request_data
            let mut request_codec = BasicCodec::new();

            // Write addresses
            request_codec.start_write_list(addresses.len() as u32)?;
            for item in &addresses {
                request_codec.write_uint8(*item)?;
            }

            let request_data = request_codec.as_bytes().to_vec();

            let response_data = self
                .client
                .perform_request(
                    ServiceId::Temp.as_u8(),
                    TempMethod::ReadSensors.as_u8(),
                    false,
                    request_data,
                )
                .await?;
            // Deserialize response_data
            if response_data.is_empty() {
                return Err("Empty response data received".into());
            }

            let mut response_codec = BasicCodec::from_data(response_data);

            // Read return value
            let result = (&mut response_codec).read_bool()?;
            Ok(result)
        }
    }
}

/// =======================================================================
/// TempAsync
/// =======================================================================

pub mod temp_async_server {
    use super::*;
    use std::sync::Arc;

    /// Generated trait containing eRPC methods that should be implemented for use with TempAsyncServer.
    #[async_trait]
    pub trait TempAsync: Send + Sync + 'static {
        /// <function(1) alarm_fired-><member (return):(void)> [<struct (fn) [0:<member addr:SensorAddress>, 1:<member temp:float>]>]>
        async fn alarm_fired(
            &self,
            addr: u8,
            temp: f32,
        ) -> Result<(), Box<dyn std::error::Error + Send + Sync>>;
        /// <function(2) read_results-><member (return):(void)> [<struct (fn) [0:<member results:(list)>, 1:<member count:uint32>]>]>
        async fn read_results(
            &self,
            results: Vec<SensorReadResult>,
        ) -> Result<(), Box<dyn std::error::Error + Send + Sync>>;
    }

    /// Server wrapper for TempAsync service
    pub struct TempAsyncServer<T>
    where
        T: TempAsync,
    {
        inner: Arc<T>,
        base_service: BaseService,
    }

    impl<T> TempAsyncServer<T>
    where
        T: TempAsync,
    {
        /// Create a new TempAsyncServer with service implementation
        pub fn new(inner: T) -> Self {
            let inner_arc = Arc::new(inner);
            let base_service = Self::create_base_service(&inner_arc);
            Self {
                inner: inner_arc,
                base_service,
            }
        }

        /// Get a reference to the inner service implementation
        pub fn get_ref(&self) -> &T {
            &self.inner
        }

        /// Get the inner service implementation
        pub fn into_inner(self) -> Arc<T> {
            self.inner
        }

        fn create_base_service(service: &Arc<T>) -> BaseService {
            let mut base_service = BaseService::new(ServiceId::TempAsync.as_u8());

            // Register all method handlers
            Self::register_alarm_fired(&mut base_service, Arc::clone(service));
            Self::register_read_results(&mut base_service, Arc::clone(service));

            base_service
        }

        fn register_alarm_fired(base_service: &mut BaseService, service: Arc<T>) {
            struct AlarmFiredHandler<T: TempAsync> {
                service: Arc<T>,
            }

            #[async_trait]
            impl<T: TempAsync> MethodHandler for AlarmFiredHandler<T> {
                async fn handle(&self, sequence: u32, codec: &mut dyn Codec) -> ErpcResult<()> {
                    // Deserialize addr parameter
                    let addr = codec.read_uint8()?;

                    // Deserialize temp parameter
                    let temp = codec.read_float()?;

                    let result = self.service.alarm_fired(addr, temp).await;
                    match result {
                        Ok(_) => {
                            let reply_info = MessageInfo::new(
                                MessageType::Reply,
                                ServiceId::TempAsync.as_u8(),
                                TempAsyncMethod::AlarmFired.as_u8(),
                                sequence,
                            );
                            codec.start_write_message(&reply_info)?;
                            // Serialize response
                            Ok(())
                        }
                        Err(_e) => {
                            let reply_info = MessageInfo::new(
                                MessageType::Reply,
                                ServiceId::TempAsync.as_u8(),
                                TempAsyncMethod::AlarmFired.as_u8(),
                                sequence,
                            );
                            codec.start_write_message(&reply_info)?;
                            // Send error response with default out parameters
                            Ok(())
                        }
                    }
                }
            }

            base_service.add_method(
                TempAsyncMethod::AlarmFired.as_u8(),
                AlarmFiredHandler { service },
            );
        }

        fn register_read_results(base_service: &mut BaseService, service: Arc<T>) {
            struct ReadResultsHandler<T: TempAsync> {
                service: Arc<T>,
            }

            #[async_trait]
            impl<T: TempAsync> MethodHandler for ReadResultsHandler<T> {
                async fn handle(&self, sequence: u32, codec: &mut dyn Codec) -> ErpcResult<()> {
                    // Deserialize results parameter
                    let results = (|| -> ErpcResult<Vec<_>> {
                        let list_len = codec.start_read_list()?;
                        let mut list = Vec::new();
                        for _ in 0..list_len {
                            list.push(SensorReadResult::read(codec)?);
                        }
                        Ok(list)
                    })()?;

                    let _ = self.service.read_results(results).await;
                    Ok(())
                }
            }

            base_service.add_method(
                TempAsyncMethod::ReadResults.as_u8(),
                ReadResultsHandler { service },
            );
        }
    }

    /// Implementation of Service trait for TempAsyncServer
    #[async_trait]
    impl<T> Service for TempAsyncServer<T>
    where
        T: TempAsync,
    {
        fn service_id(&self) -> u8 {
            self.base_service.service_id()
        }

        async fn handle_invocation(
            &self,
            method_id: u8,
            sequence: u32,
            codec: &mut dyn Codec,
        ) -> ErpcResult<()> {
            self.base_service
                .handle_invocation(method_id, sequence, codec)
                .await
        }

        fn supported_methods(&self) -> Vec<u8> {
            self.base_service.supported_methods()
        }
    }

    /// Client implementation for TempAsync
    pub struct TempAsyncClient<'a, T>
    where
        T: Transport,
    {
        client: &'a mut ClientManager<T, BasicCodecFactory>,
    }

    /// TempAsync client implementation
    /// Matches eRPC IDL interface exactly with proper serialization
    impl<'a, T> TempAsyncClient<'a, T>
    where
        T: Transport,
    {
        pub fn new(client_manager: &'a mut ClientManager<T, BasicCodecFactory>) -> Self {
            Self {
                client: client_manager,
            }
        }

        /// <function(1) alarm_fired-><member (return):(void)> [<struct (fn) [0:<member addr:SensorAddress>, 1:<member temp:float>]>]>
        pub async fn alarm_fired(
            &mut self,
            addr: u8,
            temp: f32,
        ) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
            // Serialize parameters to request_data
            let mut request_codec = BasicCodec::new();

            // Write addr
            request_codec.write_uint8(addr)?;
            // Write temp
            request_codec.write_float(temp)?;

            let request_data = request_codec.as_bytes().to_vec();

            let response_data = self
                .client
                .perform_request(
                    ServiceId::TempAsync.as_u8(),
                    TempAsyncMethod::AlarmFired.as_u8(),
                    false,
                    request_data,
                )
                .await?;
            Ok(())
        }

        /// <function(2) read_results-><member (return):(void)> [<struct (fn) [0:<member results:(list)>, 1:<member count:uint32>]>]>
        pub async fn read_results(
            &mut self,
            results: Vec<SensorReadResult>,
        ) -> Result<(), Box<dyn std::error::Error + Send + Sync>> {
            // Serialize parameters to request_data
            let mut request_codec = BasicCodec::new();

            // Write results
            request_codec.start_write_list(results.len() as u32)?;
            for item in &results {
                item.write(&mut request_codec)?;
            }

            let request_data = request_codec.as_bytes().to_vec();

            let _ = self
                .client
                .perform_request(
                    ServiceId::TempAsync.as_u8(),
                    TempAsyncMethod::ReadResults.as_u8(),
                    true,
                    request_data,
                )
                .await?;
            Ok(())
        }
    }
}
