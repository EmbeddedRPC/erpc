{% if mlComment != "" %}
{$mlComment}

{% endif %}
//
// Generated by erpcgen {$erpcVersion} on {$todaysDate}.
//
// AUTOGENERATED - DO NOT EDIT
//

#![allow(unused_imports)]
#![allow(unused_variables)]
#![allow(dead_code)]
#![allow(non_camel_case_types)]
#![allow(unused_parens)]

use async_trait::async_trait;
use erpc_rust::{
    auxiliary::{MessageInfo, MessageType},
    codec::{BasicCodec, BasicCodecFactory, Codec},
    error::SerializationError,
    server::{BaseService, MethodHandler, Service},
    transport::Transport,
    ClientManager, ErpcResult,
};
use serde::{Deserialize, Serialize};
use std::sync::Arc;

{% if not empty(group.constants) %}
/// Constants from IDL
{% for constant in group.constants %}
{$constant.comment}
pub const {$constant.name}: {$constant.type} = {$constant.value};
{% endfor -- constants %}

{% endif -- constants %}
{% if not empty(group.interfaces) %}
/// Service IDs (automatically assigned by eRPC generator based on interface order)
#[repr(u8)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ServiceId {
{% for interface in group.interfaces %}
    {$interface.name} = {$interface.id},
{% endfor -- interfaces %}
}

impl ServiceId {
    pub fn as_u8(self) -> u8 {
        self as u8
    }
}

// Method IDs for each service
{% for interface in group.interfaces %}
/// {$interface.name} method IDs
#[repr(u8)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum {$interface.name}Method {
{% for function in interface.functions %}
    {$function.constName} = {$function.id},
{% endfor -- functions %}
}

impl {$interface.name}Method {
    pub fn as_u8(self) -> u8 {
        self as u8
    }
}

{% endfor -- interfaces %}
{% endif -- interfaces %}
{% if not empty(group.typeAliases) %}
{% for alias in group.typeAliases %}
{$alias.comment}
pub type {$alias.name} = {$alias.type};
{% endfor -- aliases %}

{% endif -- typeAliases %}
{% if not empty(group.enums) %}
{% for enum in group.enums %}
{$enum.comment}
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[repr({$enum.reprType})]
pub enum {$enum.name} {
{% for member in enum.members %}
    {$member.comment}
    {$member.name} = {$member.value}, // {$member.originalName} in eRPC
{% endfor -- members %}
}

impl Default for {$enum.name} {
    fn default() -> Self {
        {$enum.name}::{$enum.firstMember}
    }
}

impl {$enum.name} {
    pub fn write(&self, codec: &mut dyn Codec) -> ErpcResult<()> {
        {$enum.writeCode}
        Ok(())
    }
    
    pub fn read(codec: &mut dyn Codec) -> ErpcResult<Self> {
        let value = {$enum.readCode}?;
        match value {
{% for member in enum.members %}
            {$member.value} => Ok(Self::{$member.name}),
{% endfor -- members %}
            _ => Err(SerializationError::InvalidEnumValue { 
                value: value as i32, 
                type_name: "{$enum.name}".to_string() 
            }.into()),
        }
    }
}

{% endfor -- enums %}
{% endif -- enums %}
{% if not empty(group.structs) %}
{% for struct in group.structs %}
{$struct.comment}
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct {$struct.name} {
{% for member in struct.members %}
    {$member.comment}
    pub {$member.name}: {$member.type}, // {$member.originalType} {$member.originalName}
{% endfor -- members %}
}

impl Default for {$struct.name} {
    fn default() -> Self {
        Self {
{% for member in struct.members %}
            {$member.name}: {$member.defaultValue},
{% endfor -- members %}
        }
    }
}

impl {$struct.name} {
    pub fn write(&self, codec: &mut dyn Codec) -> ErpcResult<()> {
{% for member in struct.members %}
        {$member.writeCode}
{% endfor -- members %}
        Ok(())
    }
    
    pub fn read(codec: &mut dyn Codec) -> ErpcResult<Self> {
        Ok(Self {
{% for member in struct.members %}
            {$member.name}: {$member.readCode}?,
{% endfor -- members %}
        })
    }
}

{% endfor -- structs %}
{% endif -- structs %}
{% if not empty(group.interfaces) %}
{% for interface in group.interfaces %}
/// =======================================================================
/// {$interface.name}
/// =======================================================================

pub mod {$interface.moduleName} {
    use super::*;
    use std::sync::Arc;

{% if interface.generateServer %}
    /// Generated trait containing eRPC methods that should be implemented for use with {$interface.name}Server.
    #[async_trait]
    pub trait {$interface.name}: Send + Sync + 'static {
{% for function in interface.functions %}
        {$function.comment}
        async fn {$function.name}(&self{$function.parameters}){$function.returnType};
{% endfor -- functions %}
    }

    /// Server wrapper for {$interface.name} service
    pub struct {$interface.name}Server<T>
    where
        T: {$interface.name},
    {
        inner: Arc<T>,
        base_service: BaseService,
    }

    impl<T> {$interface.name}Server<T>
    where
        T: {$interface.name},
    {
        /// Create a new {$interface.name}Server with service implementation
        pub fn new(inner: T) -> Self {
            let inner_arc = Arc::new(inner);
            let base_service = Self::create_base_service(&inner_arc);
            Self {
                inner: inner_arc,
                base_service,
            }
        }

        /// Get a reference to the inner service implementation
        pub fn get_ref(&self) -> &T {
            &self.inner
        }

        /// Get the inner service implementation
        pub fn into_inner(self) -> Arc<T> {
            self.inner
        }

        fn create_base_service(service: &Arc<T>) -> BaseService {
            let mut base_service = BaseService::new(ServiceId::{$interface.name}.as_u8());
            
            // Register all method handlers
{% for function in interface.functions %}
            Self::register_{$function.name}(&mut base_service, Arc::clone(service));
{% endfor -- functions %}
            
            base_service
        }

{% for function in interface.functions %}
        fn register_{$function.name}(base_service: &mut BaseService, service: Arc<T>) {
            struct {$function.handlerName}<T: {$interface.name}> {
                service: Arc<T>,
            }
            
            #[async_trait]
            impl<T: {$interface.name}> MethodHandler for {$function.handlerName}<T> {
                async fn handle(&self, sequence: u32, codec: &mut dyn Codec) -> ErpcResult<()> {
{$function.serverHandlerCode}
                }
            }
            
            base_service.add_method({$interface.name}Method::{$function.constName}.as_u8(), {$function.handlerName} { service });
        }

{% endfor -- functions %}
    }

    /// Implementation of Service trait for {$interface.name}Server
    #[async_trait]
    impl<T> Service for {$interface.name}Server<T>
    where
        T: {$interface.name},
    {
        fn service_id(&self) -> u8 {
            self.base_service.service_id()
        }

        async fn handle_invocation(
            &self,
            method_id: u8,
            sequence: u32,
            codec: &mut dyn Codec,
        ) -> ErpcResult<()> {
            self.base_service.handle_invocation(method_id, sequence, codec).await
        }

        fn supported_methods(&self) -> Vec<u8> {
            self.base_service.supported_methods()
        }
    }
{% endif -- generateServer %}

{% if interface.generateClient %}
    /// Client implementation for {$interface.name}
    pub struct {$interface.name}Client<'a, T>
    where
        T: Transport,
    {
        client: &'a mut ClientManager<T, BasicCodecFactory>,
    }

    /// {$interface.name} client implementation
    /// Matches eRPC IDL interface exactly with proper serialization
    impl<'a, T> {$interface.name}Client<'a, T>
    where
        T: Transport,
    {
        pub fn new(client_manager: &'a mut ClientManager<T, BasicCodecFactory>) -> Self {
            Self {
                client: client_manager,
            }
        }

{% for function in interface.functions %}
        {$function.comment}
        pub async fn {$function.name}(&mut self{$function.clientParameters}){$function.clientReturnType} {
            {$function.clientMethodCode}
        }

{% endfor -- functions %}
    }
{% endif -- generateClient %}
}

{% endfor -- interfaces %}
{% endif -- interfaces %}
