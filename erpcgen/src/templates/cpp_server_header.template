{% if mlComment != ""%}
{$mlComment}

{% endif %}
{$commonHeader()}

#if !defined({$serverCppGuardMacro})
#define {$serverCppGuardMacro}

#include "{$interfaceCppHeaderName}"

#include "erpc_server.hpp"
#include "{$codecHeader}"

{$checkVersion()}
{$>checkCrc()}
{$fillNamespaceBegin()>}

{% for iface in group.interfaces %}
/*!
 * @brief Service subclass for {$iface.name}.
 */
class {$iface.serviceClassName} : public erpc::Service
{
public:
    {$iface.serviceClassName}({$iface.interfaceClassName} *_{$iface.interfaceClassName});

    virtual ~{$iface.serviceClassName}();

    /*! @brief return service interface handler. */
    {$iface.interfaceClassName}* getHandler(void);

    /*! @brief Call the correct server shim based on method unique ID. */
    virtual erpc_status_t handleInvocation(uint32_t methodId, uint32_t sequence, erpc::Codec * codec, erpc::MessageBufferFactory *messageFactory, erpc::Transport * transport);

private:
    /*! @brief Function pointer type for shim functions */
    typedef erpc_status_t ({$iface.serviceClassName}::*ShimFunction)(erpc::{$codecClass} * codec, erpc::MessageBufferFactory *messageFactory, erpc::Transport * transport, uint32_t sequence);
    
    /*! @brief Compile-time hash table entry structure */
    struct FunctionEntry {
        uint32_t id;
        ShimFunction func;
        const char* name;  // For debugging
    };
    
    /*! @brief Hash table size (power of 2, load factor ~0.65) */
    static constexpr uint32_t HASH_TABLE_SIZE = {$iface.hashTable.size};
    static constexpr uint32_t FUNCTION_COUNT = {$iface.hashTable.functionCount};
    
    /*! @brief Compile-time hash function (Knuth multiplicative method) */
    static constexpr uint32_t hash_function_id(uint32_t id) {
        uint32_t hash = id;
        hash = ((hash >> 16) ^ hash) * 0x45d9f3bU;
        hash = ((hash >> 16) ^ hash) * 0x45d9f3bU;
        hash = (hash >> 16) ^ hash;
        return hash & (HASH_TABLE_SIZE - 1);
    }
    
    /*! @brief Get the pre-computed hash table */
    static const FunctionEntry* getFunctionTable();
    
    /*! @brief Find function by ID using compile-time hash table */
    ShimFunction findFunction(uint32_t methodId) const;

    {$iface.interfaceClassName} *m_handler;
{%  for fn in iface.functions %}
    /*! @brief Server shim for {$fn.name} of {$iface.name} interface. */
    erpc_status_t {$fn.name}_shim(erpc::{$codecClass} * codec, erpc::MessageBufferFactory *messageFactory, erpc::Transport * transport, uint32_t sequence);{$loop.addNewLineIfNotLast}
{%  endfor -- fn %}
};

{% endfor -- iface %}
{$fillNamespaceEnd()}
#endif // {$serverCppGuardMacro}
