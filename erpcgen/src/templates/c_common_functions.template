{#--------------------commonHeader----------------------#}
{% def commonHeader() %}
/*
 * Generated by erpcgen {$erpcVersion} on {$todaysDate}.
 *
 * AUTOGENERATED - DO NOT EDIT
 */
{% enddef --commonHeader %}

{% def checkVersion() %}
#if {$erpcVersionNumber} != ERPC_VERSION_NUMBER
#error "The generated shim code version is different to the rest of eRPC code."
#endif
{% enddef --checkVersion %}

{% def checkCrc() %}
#if !defined(ERPC_GENERATED_CRC) || ERPC_GENERATED_CRC != {$crc16}
#error "Macro 'ERPC_GENERATED_CRC' should be defined with value {$crc16}."
#endif
{% enddef --checkCrc %}

{% def generateCrcVariable() %}
// for mdk/keil do not forgett add "--muldefweak" for linker
extern const uint32_t erpc_generated_crc;
#pragma weak erpc_generated_crc
extern const uint32_t erpc_generated_crc = {$crc16};
{% enddef --checkCrc %}

{# ---------------- constantsDefinitions ---------------- #}
{% def constantsDefinitions(consts) %}
{% if not empty(consts) %}

// Constant variable definitions
{%  for c in consts %}
#pragma weak {$c.name}
extern const {$c.typeAndName} = {$c.value};
{%  endfor -- consts %}
{% endif %}
{% enddef -- constantsDefinitions %}

{# ---------------- symbolHeader ---------------- #}
{% def symbolHeader(symbols, way, shared) %}
{% if symbols %}
{%  for s in symbols if (shared == "def") || (shared == "noSharedMem" && s.noSharedMem) %}
{%   if s.type == "struct" %}
{%    if way == "serial" %}
{$ structSerialHeader(s, shared)}
{%    else %}
{$ structDeserialHeader(s, shared)}
{%    endif -- way == "serial" %}
{%   else %}
{%    if way == "serial" %}
{$ unionSerialHeader(s, shared)}
{%    else %}
{$ unionDeserialHeader(s, shared)}
{%    endif -- way == "serial" %}
{%   endif -- s.type == "union/struct" %}
{%  endfor -- symbols %}
{% endif -- symbols%}
{% enddef -- serialHeader %}

{# ---------------- symbolSource ---------------- #}
{% def symbolSource(symbols, way, shared) %}
{% if symbols %}
{%  for s in symbols if (shared == "def") || (shared == "noSharedMem" && s.noSharedMem) %}
{%   if s.type == "struct" %}
{%    if way == "serial" %}
{$ structSerialSource(s, shared)}
{%    else %}
{$ structDeserialSource(s, shared)}
{%    endif -- way == "serial" %}
{%   else -- s.type == "union/struct" %}
{%    if way == "serial" %}
{$ unionSerialSource(s, shared)}
{%    else %}
{$ unionDeserialSource(s, shared)}
{%    endif -- way == "serial" %}
{%   endif -- s.type == "union/struct" %}
{%  endfor -- symbols %}
{% endif -- symbols%}
{% enddef -- serialHeader %}

{# ---------------- symbolFreeSpaceHeader ---------------- #}
{% def symbolFreeSpaceHeader(symbols, shared) %}
{% if symbols %}
{%  for s in symbols if (shared == "def") || (shared == "noSharedMem" && s.noSharedMem) %}
{%   if s.type == "struct" %}
{$ structFreeSpaceHeader(s, shared)}
{%   else %}
{$ unionFreeSpaceHeader(s, shared)}
{%   endif %}
{%  endfor -- symbols %}
{% endif -- symbols%}
{% enddef -- serialHeader %}

{# ---------------- symbolFreeSpaceSource ---------------- #}
{% def symbolFreeSpaceSource(symbols, shared) %}
{% if symbols %}
{%  for s in symbols if (shared == "def") || (shared == "noSharedMem" && s.noSharedMem) %}
{%   if s.type == "struct" %}
{$ structFreeSpaceSource(s, shared)}
{%   else %}
{$ unionFreeSpaceSource(s, shared)}
{%   endif %}
{%  endfor -- symbols %}
{% endif -- symbols%}
{% enddef -- serialHeader %}

{# ---------------- structDeserialHeader ---------------- #}
{% def structDeserialHeader(struct, shared) %}
{%   if struct.noSharedMem && shared == "noSharedMem" %}
//! @brief Function to read no shared member of shared struct {$struct.name}
static int32_t read_{$struct.name}_struct_shared(erpc::Codec * codec, {$struct.name} * data);
{%   else %}
//! @brief Function to read struct {$struct.name}
static int32_t read_{$struct.name}_struct(erpc::Codec * codec, {$struct.name} * data);
{%   endif %}
{% enddef -- structDeserialHeader %}

{# ---------------- structSerialHeader ---------------- #}
{% def structSerialHeader(struct, shared) %}
{%   if struct.noSharedMem && shared == "noSharedMem" %}
//! @brief Function to write no shared member of shared struct {$struct.name}
static int32_t write_{$struct.name}_struct_shared(erpc::Codec * codec, const {$struct.name} * data);
{%   else %}
//! @brief Function to write struct {$struct.name}
static int32_t write_{$struct.name}_struct(erpc::Codec * codec, const {$struct.name} * data);
{%   endif %}
{% enddef  -- structSerialHeader %}

{# ---------------- structDeserialSource ---------------- #}
{% def structDeserialSource(struct, shared) %}
{%   if struct.noSharedMem && shared == "noSharedMem" %}
//! @brief Read no shared member of shared struct {$struct.name} function implementation
static int32_t read_{$struct.name}_struct_shared(erpc::Codec * codec, {$struct.name} * data)
{%   else %}
// Read struct {$struct.name} function implementation
static int32_t read_{$struct.name}_struct(erpc::Codec * codec, {$struct.name} * data)
{%   endif %}
{
{%   if struct.hasNullableMember %}
    bool isNull;
{%   endif -- hasNullableMember %}
{%   if struct.genStructWrapperF %}
{%    if struct.needTempVariable %}
    int32_t _tmp_local;
{%    endif %}
    {%    if errVar != ""  %}erpc_status_t {$errVar}{%    endif %}codec->startReadStruct();
{%   else %}
{%    if errVar != "" %}
    erpc_status_t {$errVar}kErpcStatus_Success;
{%    endif %}
{%   endif %}
{%   for mem in struct.members if (shared == "def" && not mem.serializedViaMember) || (mem.noSharedMem && shared == "noSharedMem") %}
{%    if mem.isNullable %}
{$> addInfraErrorChecksBegin("    ")}
{$infraErrIndents}    {$infraErrVar}codec->readNullFlag(&isNull);
{$infraErrIndents}    if (!isNull)
{$infraErrIndents}    {
{% if source == "server" && !empty(mem.coderCall.memberAllocation) %}
{$mem.coderCall.memberAllocation}
{% endif %}
{$addInfraErrorChecks(infraErrIndents & "        ", mem.coderCall.decode(mem.coderCall))}
{$infraErrIndents}    }
{$infraErrIndents}    else
{$infraErrIndents}    {
{$infraErrIndents}        {$mem.coderCall.name}{$mem.structElements} = NULL;
{$infraErrIndents}        {$mem.coderCall.name}{$mem.structElementsCount} = 0;
{$infraErrIndents}    }
{$> addInfraErrorChecksEnd("    ") }{$loop.addNewLineIfNotLast}
{%    else -- notNullable %}
{% if source == "server" && !empty(mem.coderCall.memberAllocation) %}
{$mem.coderCall.memberAllocation}
{% endif %}
{$addInfraErrorChecks("    ", mem.coderCall.decode(mem.coderCall))}{$loop.addNewLineIfNotLast}
{%    endif -- notNullable %}
{%   endfor -- struct.members %}
{%   if struct.genStructWrapperF %}

{$> addInfraErrorChecksBegin("    ") }
{$infraErrIndents}    {$infraErrVar}codec->endReadStruct();
{$> addInfraErrorChecksEnd("    ") }
{%   endif %}
{%   if errVar != ""  %}
    return err;
{%   else %}
    return kErpcStatus_Success;
{%   endif %}
}
{% enddef -- structDeserialSource %}

{# ---------------- structSerialSource ---------------- #}
{% def structSerialSource(struct, shared) %}
{%   if struct.noSharedMem && shared == "noSharedMem" %}
// Write no shared member of shared struct {$struct.name} function implementation
static int32_t write_{$struct.name}_struct_shared(erpc::Codec * codec, const {$struct.name} * data)
{%   else %}
// Write struct {$struct.name} function implementation
static int32_t write_{$struct.name}_struct(erpc::Codec * codec, const {$struct.name} * data)
{%   endif %}
{
{%   if struct.genStructWrapperF %}
    {%    if errVar != ""  %}erpc_status_t {$errVar}{%    endif %}codec->startWriteStruct();
{%   else %}
{%    if errVar != "" %}
    erpc_status_t {$errVar}kErpcStatus_Success;
{%    endif %}
{%   endif %}
{%   for mem in struct.members if (shared == "def" && not mem.serializedViaMember) || (mem.noSharedMem && shared == "noSharedMem") %}
{%    if mem.isNullable %}
{$> addInfraErrorChecksBegin("    ") }
{$infraErrIndents}    if ({$mem.coderCall.name}{$mem.structElements} == NULL)
{$infraErrIndents}    {
{$infraErrIndents}        {$infraErrVar}codec->writeNullFlag(true);
{$infraErrIndents}    }
{$infraErrIndents}    else
{$infraErrIndents}    {
{$infraErrIndents}        {$infraErrVar}codec->writeNullFlag(false);
{$addInfraErrorChecks(infraErrIndents & "        ", mem.coderCall.encode(mem.coderCall))}
{$infraErrIndents}    }
{$> addInfraErrorChecksEnd("    ") }{$loop.addNewLineIfNotLast}
{%    else -- notNullable %}
{$addInfraErrorChecks("    ", mem.coderCall.encode(mem.coderCall))}{$loop.addNewLineIfNotLast}
{%    endif -- notNullable %}
{%   endfor -- struct.members %}
{%   if struct.genStructWrapperF %}

{$> addInfraErrorChecksBegin("    ") }
{$infraErrIndents}    {$infraErrVar}codec->endWriteStruct();
{$> addInfraErrorChecksEnd("    ") }
{%   endif %}
{%   if errVar != ""  %}
    return err;
{%   else %}
    return kErpcStatus_Success;
{%   endif %}
}
{% enddef -- structSerialSource %}

{# ---------------- structFreeSpaceHeader ---------------- #}
{% def structFreeSpaceHeader(struct, shared) %}
{%   if struct.noSharedMem && shared == "noSharedMem" %}
//! @brief Function to free space allocated inside no shared member of shared struct {$struct.name}
static void free_{$struct.name}_struct_shared({$struct.name} * data);
{%   else %}
//! @brief Function to free space allocated inside struct {$struct.name}
static void free_{$struct.name}_struct({$struct.name} * data);
{%   endif %}
{% enddef  -- structFreeSpaceHeader %}

{# ---------------- structFreeSpaceSource ---------------- #}
{% def structFreeSpaceSource(struct, shared) %}
{%   if struct.noSharedMem && shared == "noSharedMem" %}
// Free space allocated inside no shared member of shared struct {$struct.name} function implementation
static void free_{$struct.name}_struct_shared({$struct.name} * data)
{%   else %}
// Free space allocated inside struct {$struct.name} function implementation
static void free_{$struct.name}_struct({$struct.name} * data)
{%   endif %}
{
{%   for mem in struct.membersToFree if (shared == "def" && not mem.serializedViaMember) || (mem.noSharedMem && shared == "noSharedMem") %}
{$addIndent("    ", mem.coderCall.freeingCall(mem.coderCall))}
{%    if !empty(mem.coderCall.memberAllocation) %}
{$addIndent("    ", mem.coderCall.freeingCall2(mem.coderCall))}
{%    endif%}{$loop.addNewLineIfNotLast}
{%   endfor -- struct.members %}
}
{% enddef -- structFreeSpaceSource %}

{# ---------------- unionDeserialHeader ---------------- #}
{% def unionDeserialHeader(union, shared) %}
{%   if union.noSharedMem && shared == "noSharedMem" %}
//! @brief Function to read  no shared member of shared union {$union.name}
static int32_t read_{$union.name}_union_shared(erpc::Codec * codec, int32_t * discriminator, {$union.name} * data);
{%   else %}
//! @brief Function to read union {$union.name}
static int32_t read_{$union.name}_union(erpc::Codec * codec, int32_t * discriminator, {$union.name} * data);
{%   endif %}
{% enddef -- unionDeserialHeader %}

{# ---------------- unionSerialHeader ---------------- #}
{% def unionSerialHeader(union, shared) %}
{%   if union.noSharedMem && shared == "noSharedMem" %}
//! @brief Function to write  no shared member of shared union {$union.name}
static int32_t write_{$union.name}_union_shared(erpc::Codec * codec, int32_t discriminator, const {$union.name} * data);
{%   else %}
//! @brief Function to write union {$union.name}
static int32_t write_{$union.name}_union(erpc::Codec * codec, int32_t discriminator, const {$union.name} * data);
{%   endif %}
{% enddef  -- unionSerialHeader %}

{# ---------------- unionDeserialSource ---------------- #}
{% def unionDeserialSource(union, shared) %}
{%   if union.noSharedMem && shared == "noSharedMem" %}
// Read no shared member of shared union {$union.name} function implementation
static int32_t read_{$union.name}_union_shared(erpc::Codec * codec, int32_t * discriminator, {$union.name} * data)
{%   else %}
// Read union {$union.name} function implementation
static int32_t read_{$union.name}_union(erpc::Codec * codec, int32_t * discriminator, {$union.name} * data)
{%   endif %}
{
{%   if errVar != "" %}
    erpc_status_t {$errVar}kErpcStatus_Success;
{%   endif %}
{%   if union.needTempVariable %}
    int32_t _tmp_local;
{%   endif %}
{$addIndent("    ", decodeUnionType(union.coderCall))}
{%   if errVar != ""  %}
    return err;
{%   else %}
    return kErpcStatus_Success;
{%   endif %}
}
{% enddef -- unionDeserialSource %}

{# ---------------- unionSerialSource ---------------- #}
{% def unionSerialSource(union, shared) %}
{%   if union.noSharedMem && shared == "noSharedMem" %}
// Write no shared member of shared union {$union.name} function implementation
static int32_t write_{$union.name}_union_shared(erpc::Codec * codec, int32_t discriminator, const {$union.name} * data)
{%   else %}
// Write union {$union.name} function implementation
static int32_t write_{$union.name}_union(erpc::Codec * codec, int32_t discriminator, const {$union.name} * data)
{%   endif %}
{
{%    if errVar != "" %}
    erpc_status_t {$errVar}kErpcStatus_Success;
{%    endif %}
{$addIndent("    ", encodeUnionType(union.coderCall))}
{%   if errVar != ""  %}
    return err;
{%   else %}
    return kErpcStatus_Success;
{%   endif %}
}
{% enddef -- unionSerialSource %}

{# ---------------- unionFreeSpaceHeader ---------------- #}
{% def unionFreeSpaceHeader(union, shared) %}
{%   if union.noSharedMem && shared == "noSharedMem" %}
//! @brief Function to free space allocated inside no shared member of shared union {$union.name}
static void free_{$union.name}_union_shared(int32_t discriminator, {$union.name} * data);
{%   else %}
//! @brief Function to free space allocated inside union {$union.name}
static void free_{$union.name}_union(int32_t discriminator, {$union.name} * data);
{%   endif %}
{% enddef  -- unionFreeSpaceHeader %}

{# ---------------- unionFreeSpaceSource ---------------- #}
{% def unionFreeSpaceSource(union, shared) %}
{%   if union.noSharedMem && shared == "noSharedMem" %}
// Free space allocated inside no shared member of shared union {$union.name} function implementation
static void free_{$union.name}_union_shared(int32_t discriminator, {$union.name} * data)
{%   else %}
// Free space allocated inside union {$union.name} function implementation
static void free_{$union.name}_union(int32_t discriminator, {$union.name} * data)
{%   endif %}
{
{$addIndent("    ", freeUnion(union.coderCall))}
}
{% enddef -- unionFreeSpaceSource %}

{# ---------------- callbacksTable ---------------- #}
{% def callbackTable(functionsTypes) %}
{% if functionsTypes %}
{%  for f in functionsTypes %}
{%   if count(f.callbacks) > 1 %}
static const {$f.name} _{$f.name}[] = { {%    for c in f.callbacks %}{$c.name}{%     if !loop.last %}, {%     endif -- loop.last %}{%    endfor -- f.callbacks %} };
{%   endif -- f.callbacks.size() %}
{%  endfor -- functionsTypes %}
{%  endif -- functionsTypes %}
{% enddef ------------------------------- callbackTable %}

{# ---------------- freeData ---------------- #}
{% def freeData(info) %}
if ({$info.freeName})
{
    erpc_free({$info.freeName});
}
{% enddef ------------------------------- freeData %}

{# ---------------- freeStruct ---------------- #}
{% def freeStruct(info) %}
{% if info.inDataContainer %}
free_{$info.typeName}_struct(&{$info.name});
{% else -- not inDataContainer %}
if ({$info.name})
{
    free_{$info.typeName}_struct({$info.name});
}
{% endif -- inDataContainer %}
{% enddef ------------------------------- freeStruct %}

{# ---------------- freeList ---------------- #}
{% def freeList(info) %}
{% if info.needFreeingCall == true %}
{$freeArray(info)}
{% endif %}
if ({$info.name})
{
    erpc_free({$info.name});
}
{% enddef ------------------------------- freeList %}

{# ---------------- freeArray ---------------- #}
{% def freeArray(info) %}
for (uint32_t {$info.forLoopCount} = 0; {$info.forLoopCount} < {$info.size}; ++{$info.forLoopCount})
{
{$addIndent("    ", info.protoNext.freeingCall(info.protoNext))}
}
{% enddef ------------------------------- freeArray %}

{# ---------------- freeUnion ---------------- #}
{% def freeUnion(info) %}
switch ({$info.dataLiteral}{$info.discriminatorName})
{
{% for case in info.cases %}
{%  if case.needCaseFreeingCall == true %}
{%   if case.name == "default" %}
{$addIndent("    ", "default:")}
{%   else %}
{$addIndent("    ", "case ")}{% if case.name != "" %}{$case.name}{% else %}{$case.value}{% endif %}:
{%   endif -- default or case %}
    {
{%   for member in case.members %}
{%    if member.isNeedFreeingCall %}
{$addIndent("        ", member.coderCall.freeingCall(member.coderCall))}
{%    endif %}
{%    if !empty(mem.coderCall.memberAllocation) %}
{$addIndent("    ", mem.coderCall.freeingCall2(mem.coderCall))}
{%    endif%}
{%   endfor -- members %}
{$addIndent("        ", "break;")}
    }
{%  endif %}
{% endfor -- cases %}
}
{% enddef ------------------------------- freeUnion %}

{% def freeUnionType(info) %}
{% if info.inDataContainer %}
free_{$info.typeName}_union({% if info.castDiscriminator %}static_cast<int32_t>({% endif %}{$info.dataLiteral}{$info.discriminatorName}{% if info.castDiscriminator %}){% endif %}, &{$info.dataLiteral}{$info.name});
{% else -- not inDataContainer %}
free_{$info.typeName}_union({% if info.castDiscriminator %}static_cast<int32_t>({% endif %}{$info.discriminatorName}{% if info.castDiscriminator %}){% endif %}, {$info.name});
{% endif -- inDataContainer %}
{% enddef ------------------------------- freeUnionType %}

{% def addInfraErrorChecks(indent, code) %}
{% if code != "" %}{% if generateInfraErrorChecks %}
{$ indent}if (!err)
{$ indent}{
{$addIndent(indent & "    ", code)}
{$ indent}}{% else %}
{$addIndent(indent, code)}{% endif %}{% endif >%}
{% enddef ------------------------------- addInfraErrorChecks %}

{% def addErrorChecks(indent, code) %}
{% if code != "" %}{% if generateInfraErrorChecks or generateAllocErrorChecks) %}
{$ indent}if (!err)
{$ indent}{
{$addIndent(indent & "    ", code)}
{$ indent}}{% else %}
{$addIndent(indent, code)}{% endif %}{% endif >%}
{% enddef ------------------------------- addInfraErrorChecks %}

{# ---------------- addInfraErrorChecksBegin---------------- #}
{% def addInfraErrorChecksBegin(indent) %}
{% if generateInfraErrorChecks %}{$ indent}if (!err)
{$ indent}{{% endif >%}
{% enddef ------------------------------- addInfraErrorChecksBegin %}

{# ---------------- addInfraErrorChecksEnd---------------- #}
{% def addInfraErrorChecksEnd(indent) %}
{% if generateInfraErrorChecks %}{$ indent}}{% endif >%}
{% enddef ------------------------------- addInfraErrorChecksEnd %}

{# ---------------- addInfraErrorChecksElse---------------- #}
{% def addInfraErrorChecksElse() %}
{% if generateInfraErrorChecks %}else
{
    break;
}{% endif >%}
{% enddef ------------------------------- addInfraErrorChecksElse %}

{% def setSharedMemAddresses() %}
{% if sharedMemBeginAddr != "" %}
#define ERPC_SHARED_MEMORY_BEGIN {$sharedMemBeginAddr}
#define ERPC_SHARED_MEMORY_END {$sharedMemEndAddr}
{% endif %}
{% enddef ------------------------------- addInfraErrorChecksElse%}

{% def unionMembersDeclaration(info) %}
{% for unionCase in info.unionCases %}
{%  if count(unionCase) > 1 %}
struct
{
{%   set indent = "    " %}
{%  else %}
{%   set indent = "" %}
{%  endif %}
{%  for unionMember in unionCase %}
{$indent}{$unionMember.typenameName};
{%  endfor %}
{%  if count(unionCase) > 1 %}
};
{%  endif %}
{% endfor%}
{% enddef ------------------------------- addInfraErrorChecksElse%}
