{#--------------------commonHeader----------------------#}
{% def commonHeader() %}
/*
 * Generated by erpcgen {$erpcVersion} on {$todaysDate}.
 *
 * AUTOGENERATED - DO NOT EDIT
 */
{% enddef --commonHeader %}

{% def checkVersion() %}
#if {$erpcVersionNumber} != ERPC_VERSION_NUMBER
#error "The generated shim code version is different to the rest of eRPC code."
#endif
{% enddef --checkVersion %}

{% def checkCrc() %}
{% if empty(crc16) == false %}

#if !defined(ERPC_GENERATED_CRC) || ERPC_GENERATED_CRC != {$crc16}
#error "Macro 'ERPC_GENERATED_CRC' should be defined with value {$crc16}."
#endif

{% endif  -- empty(crc16) == false %}
{% enddef --checkCrc %}

{% def generateCrcVariable() %}
{% if empty(crc16) == false %}
// for mdk/keil do not forgett add "--muldefweak" for linker
extern const uint32_t erpc_generated_crc;
#pragma weak erpc_generated_crc
extern const uint32_t erpc_generated_crc = {$crc16};
{% endif  -- empty(crc16) == false %}
{% enddef --checkCrc %}

{# ---------------- constantsDefinitions ---------------- #}
{% def constantsDefinitions(consts) %}
{% if not empty(consts) %}

// Constant variable definitions
{%  for c in consts %}
#pragma weak {$c.name}
extern const {$c.typeAndName} = {$c.value};
{%  endfor -- consts %}
{% endif %}
{% enddef -- constantsDefinitions %}

{# ---------------- symbolHeader ---------------- #}
{% def symbolHeader(symbols, way, shared) %}
{% if symbols %}
{%  for s in symbols if (shared == "def") || (shared == "noSharedMem" && s.noSharedMem) %}
{%   if s.type == "struct" %}
{%    if way == "serial" %}
{$ structSerialHeader(s, shared)}
{%    else %}
{$ structDeserialHeader(s, shared)}
{%    endif -- way == "serial" %}
{%   else %}
{%    if way == "serial" %}
{$ unionSerialHeader(s, shared)}
{%    else %}
{$ unionDeserialHeader(s, shared)}
{%    endif -- way == "serial" %}
{%   endif -- s.type == "union/struct" %}
{%  endfor -- symbols %}
{% endif -- symbols%}
{% enddef -- serialHeader %}

{# ---------------- symbolSource ---------------- #}
{% def symbolSource(symbols, way, shared) %}
{% if symbols %}
{%  for s in symbols if (shared == "def") || (shared == "noSharedMem" && s.noSharedMem) %}
{%   if s.type == "struct" %}
{%    if way == "serial" %}
{$ structSerialSource(s, shared)}
{%    else %}
{$ structDeserialSource(s, shared)}
{%    endif -- way == "serial" %}
{%   else -- s.type == "union/struct" %}
{%    if way == "serial" %}
{$ unionSerialSource(s, shared)}
{%    else %}
{$ unionDeserialSource(s, shared)}
{%    endif -- way == "serial" %}
{%   endif -- s.type == "union/struct" %}
{%  endfor -- symbols %}
{% endif -- symbols%}
{% enddef -- serialHeader %}

{# ---------------- symbolFreeSpaceHeader ---------------- #}
{% def symbolFreeSpaceHeader(symbols, shared) %}
{% if symbols %}
{%  for s in symbols if (shared == "def") || (shared == "noSharedMem" && s.noSharedMem) %}
{%   if s.type == "struct" %}
{$ structFreeSpaceHeader(s, shared)}
{%   else %}
{$ unionFreeSpaceHeader(s, shared)}
{%   endif %}
{%  endfor -- symbols %}
{% endif -- symbols%}
{% enddef -- serialHeader %}

{# ---------------- symbolFreeSpaceSource ---------------- #}
{% def symbolFreeSpaceSource(symbols, shared) %}
{% if symbols %}
{%  for s in symbols if (shared == "def") || (shared == "noSharedMem" && s.noSharedMem) %}
{%   if s.type == "struct" %}
{$ structFreeSpaceSource(s, shared)}
{%   else %}
{$ unionFreeSpaceSource(s, shared)}
{%   endif %}
{%  endfor -- symbols %}
{% endif -- symbols%}
{% enddef -- serialHeader %}

{# ---------------- structDeserialHeader ---------------- #}
{% def structDeserialHeader(struct, shared) %}
{%   if struct.noSharedMem && shared == "noSharedMem" %}
//! @brief Function to read no shared member of shared struct {$struct.name}
static void read_{$struct.name}_struct_shared(erpc::{$codecClass} * codec, {$struct.name} * data);
{%   else %}
//! @brief Function to read struct {$struct.name}
static void read_{$struct.name}_struct(erpc::{$codecClass} * codec, {$struct.name} * data);
{%   endif %}
{% enddef -- structDeserialHeader %}

{# ---------------- structSerialHeader ---------------- #}
{% def structSerialHeader(struct, shared) %}
{%   if struct.noSharedMem && shared == "noSharedMem" %}
//! @brief Function to write no shared member of shared struct {$struct.name}
static void write_{$struct.name}_struct_shared(erpc::{$codecClass} * codec, const {$struct.name} * data);
{%   else %}
//! @brief Function to write struct {$struct.name}
static void write_{$struct.name}_struct(erpc::{$codecClass} * codec, const {$struct.name} * data);
{%   endif %}
{% enddef  -- structSerialHeader %}

{# ---------------- structDeserialSource ---------------- #}
{% def structDeserialSource(struct, shared) %}
{%   if struct.noSharedMem && shared == "noSharedMem" %}
//! @brief Read no shared member of shared struct {$struct.name} function implementation
static void read_{$struct.name}_struct_shared(erpc::{$codecClass} * codec, {$struct.name} * data)
{%   else %}
// Read struct {$struct.name} function implementation
static void read_{$struct.name}_struct(erpc::{$codecClass} * codec, {$struct.name} * data)
{%   endif %}
{
{%   if struct.hasNullableMember %}
    bool isNull;
{%   endif -- hasNullableMember %}
{%   if struct.needTempVariable %}
    int32_t _tmp_local;
{%   endif %}
{%   for mem in struct.members if (shared == "def" && not mem.serializedViaMember) || (mem.noSharedMem && shared == "noSharedMem") %}
{%    if mem.isNullable %}
    codec->readNullFlag(&isNull);
    if (!isNull)
    {
{%     if source == "server" %}
{$> addIndent("        ", allocMem(mem.coderCall.memberAllocation))}
{%     endif %}
{$ addIndent("        ", mem.coderCall.decode(mem.coderCall))}
    }
    else
    {
        {$mem.coderCall.name}{$mem.structElements} = NULL;
        {$mem.coderCall.name}{$mem.structElementsCount} = 0;
    }{$loop.addNewLineIfNotLast}
{%    else -- notNullable %}
{% if source == "server" %}
{$> addIndent("    ", allocMem(mem.coderCall.memberAllocation))}
{% endif %}
{$addIndent("    ", mem.coderCall.decode(mem.coderCall))}{$loop.addNewLineIfNotLast}
{%    endif -- notNullable %}
{%   endfor -- struct.members %}
}
{% enddef -- structDeserialSource %}

{# ---------------- structSerialSource ---------------- #}
{% def structSerialSource(struct, shared) %}
{%   if struct.noSharedMem && shared == "noSharedMem" %}
// Write no shared member of shared struct {$struct.name} function implementation
static void write_{$struct.name}_struct_shared(erpc::{$codecClass} * codec, const {$struct.name} * data)
{%   else %}
// Write struct {$struct.name} function implementation
static void write_{$struct.name}_struct(erpc::{$codecClass} * codec, const {$struct.name} * data)
{%   endif %}
{
{%   for mem in struct.members if (shared == "def" && not mem.serializedViaMember) || (mem.noSharedMem && shared == "noSharedMem") %}
{%    if mem.isNullable %}
    if ({$mem.coderCall.name}{$mem.structElements} == NULL)
    {
        codec->writeNullFlag(true);
    }
    else
    {
        codec->writeNullFlag(false);
{$addIndent("        ", mem.coderCall.encode(mem.coderCall))}
    }{$loop.addNewLineIfNotLast}
{%    else -- notNullable %}
{$addIndent("    ", mem.coderCall.encode(mem.coderCall))}{$loop.addNewLineIfNotLast}
{%    endif -- notNullable %}
{%   endfor -- struct.members %}
}
{% enddef -- structSerialSource %}

{# ---------------- structFreeSpaceHeader ---------------- #}
{% def structFreeSpaceHeader(struct, shared) %}
{%   if struct.noSharedMem && shared == "noSharedMem" %}
//! @brief Function to free space allocated inside no shared member of shared struct {$struct.name}
static void free_{$struct.name}_struct_shared({$struct.name} * data);
{%   else %}
//! @brief Function to free space allocated inside struct {$struct.name}
static void free_{$struct.name}_struct({$struct.name} * data);
{%   endif %}
{% enddef  -- structFreeSpaceHeader %}

{# ---------------- structFreeSpaceSource ---------------- #}
{% def structFreeSpaceSource(struct, shared) %}
{%   if struct.noSharedMem && shared == "noSharedMem" %}
// Free space allocated inside no shared member of shared struct {$struct.name} function implementation
static void free_{$struct.name}_struct_shared({$struct.name} * data)
{%   else %}
// Free space allocated inside struct {$struct.name} function implementation
static void free_{$struct.name}_struct({$struct.name} * data)
{%   endif %}
{
{%   set needFreeNewline = "false" %}
{%   for mem in struct.membersToFree if (shared == "def" && not mem.serializedViaMember) || (mem.noSharedMem && shared == "noSharedMem") %}
{%    if needFreeNewline == "true" %}

{%    else %}
{%     set needFreeNewline = "true" %}
{%    endif -- needFreeNewline == "true" %}
{$addIndent("    ", mem.coderCall.freeingCall(mem.coderCall))}
{%    if empty(mem.coderCall.memberAllocation) == false %}
{$addIndent("    ", mem.coderCall.freeingCall2(mem.coderCall))}
{%    endif %}
{%   endfor -- struct.members %}
}
{% enddef -- structFreeSpaceSource %}

{# ---------------- unionDeserialHeader ---------------- #}
{% def unionDeserialHeader(union, shared) %}
{%   if union.noSharedMem && shared == "noSharedMem" %}
//! @brief Function to read  no shared member of shared union {$union.name}
static void read_{$union.name}_union_shared(erpc::{$codecClass} * codec, int32_t * discriminator, {$union.name} * data);
{%   else %}
//! @brief Function to read union {$union.name}
static void read_{$union.name}_union(erpc::{$codecClass} * codec, int32_t * discriminator, {$union.name} * data);
{%   endif %}
{% enddef -- unionDeserialHeader %}

{# ---------------- unionSerialHeader ---------------- #}
{% def unionSerialHeader(union, shared) %}
{%   if union.noSharedMem && shared == "noSharedMem" %}
//! @brief Function to write  no shared member of shared union {$union.name}
static void write_{$union.name}_union_shared(erpc::{$codecClass} * codec, int32_t discriminator, const {$union.name} * data);
{%   else %}
//! @brief Function to write union {$union.name}
static void write_{$union.name}_union(erpc::{$codecClass} * codec, int32_t discriminator, const {$union.name} * data);
{%   endif %}
{% enddef  -- unionSerialHeader %}

{# ---------------- unionDeserialSource ---------------- #}
{% def unionDeserialSource(union, shared) %}
{%   if union.noSharedMem && shared == "noSharedMem" %}
// Read no shared member of shared union {$union.name} function implementation
static void read_{$union.name}_union_shared(erpc::{$codecClass} * codec, int32_t * discriminator, {$union.name} * data)
{%   else %}
// Read union {$union.name} function implementation
static void read_{$union.name}_union(erpc::{$codecClass} * codec, int32_t * discriminator, {$union.name} * data)
{%   endif %}
{
{%   if union.needTempVariable %}
    int32_t _tmp_local;

{%   endif %}
{$addIndent("    ", decodeUnionType(union.coderCall))}
}
{% enddef -- unionDeserialSource %}

{# ---------------- unionSerialSource ---------------- #}
{% def unionSerialSource(union, shared) %}
{%   if union.noSharedMem && shared == "noSharedMem" %}
// Write no shared member of shared union {$union.name} function implementation
static void write_{$union.name}_union_shared(erpc::{$codecClass} * codec, int32_t discriminator, const {$union.name} * data)
{%   else %}
// Write union {$union.name} function implementation
static void write_{$union.name}_union(erpc::{$codecClass} * codec, int32_t discriminator, const {$union.name} * data)
{%   endif %}
{
{$addIndent("    ", encodeUnionType(union.coderCall))}
}
{% enddef -- unionSerialSource %}

{# ---------------- unionFreeSpaceHeader ---------------- #}
{% def unionFreeSpaceHeader(union, shared) %}
{%   if union.noSharedMem && shared == "noSharedMem" %}
//! @brief Function to free space allocated inside no shared member of shared union {$union.name}
static void free_{$union.name}_union_shared(int32_t discriminator, {$union.name} * data);
{%   else %}
//! @brief Function to free space allocated inside union {$union.name}
static void free_{$union.name}_union(int32_t discriminator, {$union.name} * data);
{%   endif %}
{% enddef  -- unionFreeSpaceHeader %}

{# ---------------- unionFreeSpaceSource ---------------- #}
{% def unionFreeSpaceSource(union, shared) %}
{%   if union.noSharedMem && shared == "noSharedMem" %}
// Free space allocated inside no shared member of shared union {$union.name} function implementation
static void free_{$union.name}_union_shared(int32_t discriminator, {$union.name} * data)
{%   else %}
// Free space allocated inside union {$union.name} function implementation
static void free_{$union.name}_union(int32_t discriminator, {$union.name} * data)
{%   endif %}
{
{$addIndent("    ", freeUnion(union.coderCall))}
}
{% enddef -- unionFreeSpaceSource %}

{# ---------------- callbacksTable ---------------- #}
{% def callbackTable(functionsTypes) %}
{% if functionsTypes %}
{%  for f in functionsTypes %}
{%   if count(f.callbacks) > 1 %}
static const {$f.name} _{$f.name}[] = { {%    for c in f.callbacks %}{$c.name}{%     if !loop.last %}, {%     endif -- loop.last %}{%    endfor -- f.callbacks %} };
{%   endif -- f.callbacks.size() %}
{%  endfor -- functionsTypes %}
{%  endif -- functionsTypes %}
{% enddef ------------------------------- callbackTable %}

{# ---------------- allocMem ---------------- #}
{% def allocMem(info) %}
{% if empty(info) == false %}
{$info.name} = ({$info.typePointerValue}) erpc_malloc({$info.size}sizeof({$info.typeValue}));
{%  if generateAllocErrorChecks == true %}
if ({$info.name} == NULL)
{
    codec->updateStatus(kErpcStatus_MemoryError);
}
{%   if info.isOutChar == true %}
else
{
    {$info.name}[{$info.chSize}] = '\0';
}
{%   endif --info.isOutChar == true %}
{%  else -- generateAllocErrorChecks == true %}
{%   if info.isOutChar == true %}
{$info.name}[{$info.chSize}] = '\0';
{%   endif --info.isOutChar == true %}
{%  endif -- generateAllocErrorChecks == true %}
{% endif -- empty(info) == false %}
{% enddef ------------------------------- allocMem %}

{# ---------------- freeData ---------------- #}
{% def freeData(info) %}
if ({$info.freeName})
{
    erpc_free({$info.freeName});
}
{% enddef ------------------------------- freeData %}

{# ---------------- freeStruct ---------------- #}
{% def freeStruct(info) %}
{% if info.inDataContainer %}
free_{$info.typeName}_struct(&{$info.name});
{% else -- not inDataContainer %}
if ({$info.name})
{
    free_{$info.typeName}_struct({$info.name});
}
{% endif -- inDataContainer %}
{% enddef ------------------------------- freeStruct %}

{# ---------------- freeList ---------------- #}
{% def freeList(info) %}
{% if info.needFreeingCall == true %}
{$freeArray(info)}
{% endif %}
if ({$info.name})
{
    erpc_free({$info.name});
}
{% enddef ------------------------------- freeList %}

{# ---------------- freeArray ---------------- #}
{% def freeArray(info) %}
for (uint32_t {$info.forLoopCount} = 0; {$info.forLoopCount} < {$info.size}; ++{$info.forLoopCount})
{
{$addIndent("    ", info.protoNext.freeingCall(info.protoNext))}
}
{% enddef ------------------------------- freeArray %}

{# ---------------- freeUnion ---------------- #}
{% def freeUnion(info) %}
switch ({$info.dataLiteral}{$info.discriminatorName})
{
{% for case in info.cases %}
{%  if case.needCaseFreeingCall == true %}
{%   if case.name == "default" %}
    default:
{%   else %}
    case {% if case.name != "" %}{$case.name}{% else %}{$case.value}{% endif %}:
{%   endif -- default or case %}
    {
{%   for member in case.members %}
{%    if member.isNeedFreeingCall %}
{$addIndent("        ", member.coderCall.freeingCall(member.coderCall))}
{%    endif %}
{%    if empty(member.coderCall.memberAllocation) == false %}
{$addIndent("        ", member.coderCall.freeingCall2(member.coderCall))}
{%    endif%}
{%   endfor -- members %}
        break;
    }
{%  endif %}
{% endfor -- cases %}
}
{% enddef ------------------------------- freeUnion %}

{% def freeUnionType(info) %}
{% if info.inDataContainer %}
free_{$info.typeName}_union({% if info.castDiscriminator %}static_cast<int32_t>({% endif %}{$info.dataLiteral}{$info.discriminatorName}{% if info.castDiscriminator %}){% endif %}, &{$info.name});
{% else -- not inDataContainer %}
if ({$info.name})
{
    free_{$info.typeName}_union({% if info.castDiscriminator %}static_cast<int32_t>({% endif %}{$info.discriminatorName}{% if info.castDiscriminator %}){% endif %}, {$info.name});
}
{% endif -- inDataContainer %}
{% enddef ------------------------------- freeUnionType %}

{% def setSharedMemAddresses() %}
{% if sharedMemBeginAddr != "" %}
#define ERPC_SHARED_MEMORY_BEGIN {$sharedMemBeginAddr}
#define ERPC_SHARED_MEMORY_END {$sharedMemEndAddr}
{% endif %}
{% enddef ------------------------------- setSharedMemAddresses %}

{% def unionMembersDeclaration(info) %}
{% for unionCase in info.unionCases %}
{%  if count(unionCase) > 1 %}
struct
{
{%   set indent = "    " %}
{%  else %}
{%   set indent = "" %}
{%  endif %}
{%  for unionMember in unionCase %}
{$indent}{$unionMember.typenameName};
{%  endfor %}
{%  if count(unionCase) > 1 %}
};
{%  endif %}
{% endfor%}
{% enddef ------------------------------- unionMembersDeclaration %}

{% def f_paramIsNullableEncode(param) %}
if ({$param.nullableName} == NULL{% if ((source == "client") && (param.direction != ReturnDirection) && (empty(param.lengthName) == false)) %} || {$param.lengthName} == NULL{% endif %})
{
    codec->writeNullFlag(true);
}
else
{
    codec->writeNullFlag(false);
{# Out will send only null information from client to server that it is not null #}
{% if param.direction != OutDirection %}
{$addIndent("    ", param.coderCall.encode(param.coderCall))}
{% endif -- param.direction != OutDirection %}
}
{% enddef ------------------------------- f_paramIsNullableEncode %}

{% def f_paramIsNullableDecode(param) %}
codec->readNullFlag(&isNull);
if (!isNull)
{
{% if source == "server" %}
{$> addIndent("    ", allocMem(param.mallocServer))}
{% endif %}
{$> addIndent("    ", allocMem(param.firstAlloc))}
{# Out will receive only null information from client to server that it is not null #}
{% if param.direction != OutDirection %}
{$addIndent("    ", param.coderCall.decode(param.coderCall))}
{% endif -- param.direction != OutDirection %}
{% if source == "server" && empty(param.nullVariable) == false %}
    _{$param.nullableName} = &{$param.nullableName};
{% endif %}
}
else
{
    {% if source == "server" && !empty(param.nullVariable) %}_{% endif %}{$param.nullableName} = NULL;
}
{% enddef ------------------------------- f_paramIsNullableDecode %}
